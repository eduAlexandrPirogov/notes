# Мутабельность как упршение модели данных

Если требуется расширить класс некотрой фичей, но наследование выглядит громоздким решением, то можно использовать способ со словарем, где мы храним 
в качестве ключа, например, хэш, а в качестве значения -- добавляемую фичу.

На ум приходят следующие мысли:
1) Добавляемая фича не используется в закрытых для изменения методах
2) Добавляемая фича экспортируется, иначе для взаимодействия с ней придется добавлять дополнительные методы
3) Должен присутствовать механизм инициализации фичи (передача параметра через конструктор например)

В качестве примера можно рассмотреть класс, по обработке звуковой дорожке:
```cpp
class Equalizer {
private:
  SoundStream soundStream;
public:
  Equalizer();
  void DecreaseVocal();
  void IncreaseVocal();
  
  void DecreaseBass();
  void IncreaseBass();
}
```

И требуется добавить дополнительную фичу, которая будет отражать информацию о звуковой дорожке (длина дорожки, тип, формат и т.п.), которая выражается в тип struct Meta.
Действительно, наследование класса ради одного поля выглядит черезчур громоздким, и, добавить структуру мета-информации struct Meta, кажется вполне нормальным решением
в закрытый для расширения класс, т.к. мы не меняем поведение самого Equalizer. Да, класс нарушает SRP, ведь struct Meta можно будет вычислить как-то на основе Equalizer,
но это кажется опять же громоздким и можно пойти на компромисс.
Мы делаем подобную структуру публичной, иначе для нее нам придется добавлять метод или инвариант, а это уже получается новый тип данных.

Теперь, обобщим данный случай до N подобных фич, которые будем хранить в мапе. Эти фичи должны как-то инициализироваться, вне зависимости от их типа данных
(в случае строки -- начальным значением, в случае struct Meta -- какими-то специфическими значениями). 
Тут мы сталкиваемся с диллемой, что:
1) либо мы инициализируем это где-то перед созданием объекта и передаем в конструктор
2) либо передаем напрямую через поля.

То есть, для N фич, в лучшем случае перед созданием объекта, содержащий эти фичи, будет n строк кода, которые создают эти фичи. Проблема также может быть 
в том, что под m ситуаций, могут быть m * n вариантов создания фич. Программист-клиент должен держать в голове момент, какой объект конкретно нужно создавать,
т.к. методов с инвариантами у нас нет, аесли есть, то почему не вынести контейнер в отдельную структуру данных?
Ещё стоит учитывать, что за язык используется, как нам хранить разные типы в одном контейнере. 
Ну и как доставать эти фичи из контейнера? Именно не через цикл, а конкретную? Вот тут есть ещё нюанс, что если мы будем искать фичу, посредством сравниваниЯ,
то как мы будем сравивать эти фичи? Тут уже вопрос иммутабельности данных.

Как по мне это выглядит серьезным усложнением в дальнейшем по следующим причинам:
1) если внесением полей нарушит SRP класса, то почему map, содержащая это поле не нарушает SPR?
2) контейнер должен быть публичным, иначе придется создавать методы для взаимодействия с подобным контейнером. Если так, то почему бы вообще не вынести 
подобный контейнер в отдельный класс, который будет содержать токен на структуру данных?
3) программист неограничен инвариантами при работе с подобными полями
4) какие фичи мы будем хранить в контейнера и как их создавать? А как доставать подобные фичи?

Пока что я вижу это как серьезное усложнение, хотя данный шаблон, скорее всего, хорошо подойдет для простых типов данных.
Подобный шаблон очень напоминает шаблон посетитель по замыслу, но вот за собой несет серьезные издержки.
