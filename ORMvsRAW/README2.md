# Ускоряем код фреймоврка в 100раз часть 2 

Примеры неожиданного результата работы кода/API

# Пример 1

В рабочем проекте постоянно фигурировали слова "справка", "справочные списки", "справочные сервисы", что в свою очередь породила огромное количество классов/методов/таблиц
с reference-словами. 
Была задача обновить API для справок, я изменил /api/references, но оказалось, этот API был не о тех "справка", а документации и комментариев особо не было.

# Пример 2 

Работа с чужим кодом. Парсер парсил http-логи. Была задача, чтобы парсились только POST запросы, и подсказали мне, чтобы я добавил одну строчку.
В итоге, добавив условие проверки, из-за невнятной постановки, неверной подсказки и того, что я не проверил весь код, задача была неверно выполнена.
(Нужно было создать новую job'y для работы с  новым источником данных)

# Пример 3

В PL/SQL была задача написать функцию для расчета прогноза на основе предыдущих показателей. Предудыщии показатели я хранил в массиве. Какого было мое удивление, что
функция для сортировки массивов целочисленных была в Postgres'e, а для float -- нет. Ну ошибка моя, т.к. не прочитал полностью документаци и написал сам функцию сортировку.


Примеры изменения типа результата

# Пример 1

В целом в рабочих проектах частенько сталкиваюсь с подобной ситуацией:
1) Берется выборка из БД
2) Эта выборка модифицируется для выдачи

Например:

```php
public function servicesForecast(Request $request)
{
   $collection = Service::where(...)
   
   foreach($collection as $item)
   {
      //Modifications things 
   }
} 
```

И семантически такого полно. Я бы создавал для этого отделньые функции в PL/SQL, где каждый подобный момент отрабатывается.

```php
public function servicesForecast(Request $request)
{
   $collection = \DB::statement("select * from servicesWithForecast($params)");
   ...
} 
```

Тем самым, мы устраняем потребность каждый раз писать новый запрос для одного и того же (семантичеки) запроса. 

# Пример 2 

В ином проекте из контейнера одной иерархии объектов постоянно удаляли дубликаты или фильтровали по условию и это была размазано по проекту:

Было
```php
public function eraseWithAdditionalDouble(array $objectArray)
{
   for(...)
      if(..)
         array_shift(..)
}

public function eraseDuplicates(array $objectArray)
{

}
```

Создал отдельную АТД для работы с контейнером объектов, которые можно отфильтровать:

```php
class FilteredContainer
{

   public function __construct(array $functionsFilter)
   {
   ...
   }
   
   public function append($object)
   {
     //pre-cond
     if()
   }
}
```
По итоге, все контейнеры объектов, которые нужно было обработать, прохидили через данный АТД, а способ фильтрации задавался лямбда-функцией.

# Пример 3

В одном рабочем проекте постоянно запрашивались данные из 3-ех таблиц, но иногда с условиями (сортировка, удалить ненужные группы и т.д.). То есть после исполнения
запроса или во-время построения похожего запроса дописывался код и засорялась кодовая база.

Добавил функцию, которая исполняет основную часть запроса + лямбда функцию, которая устанавливала сортировку и предикаты. Выглядела примерно так (была на прошлой работе):

```php
public function foreach($container, $function)
{
    for(...)
};

public function retreiveGroups($sortFunc, $predicate)
{
   //Лямбда функции возвращали дополнение к запросу ORM.
   $this->container = $this->foreach($this->container, $predicate);
};
```
В силу особенности PHP, была написана документация, какие и как писать лямбда функции
Без параметов всегда возвращался стандартный тип результатов (просто результат запроса). а с параметрами возвращался соответсвующий отсортированный и отфильтрованный результат запроса.
