# Что такое баг

## Это не баг

1) Имелась процедура, которая считывала рассчитывала финансовые данные, и раскидывала значения в таблицу А по-сервисно. Данные по-сервисам загружались в течении недели.
Загружались данные по сервисам поэтапно иногда, т.е. не все сервисы залетали в первый день работы проекта. Поэтому в качестве приляпки, было решено, если
нет данных за текущих месяц, до брать данные за предыдущий месяц. В чате постоянно всплывали сообщения "А почему данные текущего месяца похожи на данные предыдущего месяца?".

2) Имелся парсер, который парсил файл с финансами сервиса. Файл мог иметь некорретные поля. Если парсер читал некорректное поле, то в итоговый файл, в столбец,
который имел некорректное поле, в итоге имел значение "Некорректные данные". Несмотря на то, что файл имел корректные данные, и парсер об этом говорил, лучше было
бы указывать ошибку (в логах, или в таблице job_statuses).

## Это не баг, а следствие чего-то плохого

1) Не совсем про кодовую базу. Момент, когда на проекте в таблицах хранились колонки типа json пачками, дабы реализовать локальность данных, да и
PHP работает с json'ами неплохо. То есть, это такая "приляпка", как мне кажется, поскольку проще было бы использовать mongo. 

2) Для RabbitMQ на Laravel использовался паттерн builder, чтобы создать экземпляр объекта Rabbit Producer, когдо можно было бы обойтись обычным .env файлом.

## Это сбивает с толку людей

1) Была задача добавить в парсер фичу (обрабатывать только определенные поля). Используя интерфейс проекта, потратил несколько дней на выяснение, почему 
программа выдает иной результат, а не тот, который я ожидал. Оказалось, что в глубинах кода, были методы setRows, setColumns, который устаналивали columns и 
rows соответственно, из-за чего я полагал, что использую методы правильно.

2) В этом же проекте была проблема, что были метод с 5+ вложенностями, 150+ строк кода, из-за чего разобрать было его очень сложно, что он должен делать конкретно.
Это также замедлило процесс решения задачи. Писать тесты для такого метода было мучительно долго, а разобрать область определений и область значений -- невозможно почти.

## Хрупкость

1) Был парсер, который парсил файл и должен был сделать из него сиды для БД. До меня задача решалась линейно, т.е. каждая таблица не имеля ссылок на другую таблицу,
и столило просто линейно пройти файл. Когда проект развивался, потребовались новые сиды для таблиц, которые имели связи. Первоначальный парсер не подходил -- так, как
там было испольозвано много литералов, констант, массивов , больших функций. Я переписал это в универсальный парсер.

2) Проект для рассчета финансовых прогнозов. Изначально, все процедуры рассчета решили делать в БД. Несмотря на то, что PL/SQL -- процедурный язык, 
создавать гибкие процедуры довольно сложно (а может у меня не было опыта). За не имением fold, foldBack, mapReduce, приходилось плодить if-ы, 
локальные преременные и т.д. В итоге, через пару месяцев, пришлось переносить код в PHP.

## Не соответствует требованиям OSHA

Встречался только один раз и слышал один случай.

1) Сам, однажды, решил модуль, "оптимизировав" его. Модуль принимал запросы и парсил их. Загвоздка была в том, что файлы могли приходить битые (я об этом не знал).
Написал процедурную функцию, которая сокращала кодовую базу модуля в 2 раза. По итогу, рекурсивная функция заполнила стэк и убила прод, из-за того, что пришли некорректные данные.

Второй случай знакомого, в терминах могу ошибаться
2) Решил сделать миграцию или бэкап данных. Для таких вещей были написаны sh скрипты. Ему не понравилось детище, решил сделать лучше, и в итоге, когда сделал бэкап,
данные не восстановились.
