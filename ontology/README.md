# Проектные требования или проектная онтология?

# Случай 1


Работал в ТЕЛЕ2 и мы создавали веб-приложение, где можно было управлять тарифами операторов.
Опишу полностью задачу, которую требовалось решить -- создать функционал копирования тарифов. 
Например, на основе 1 тарифа нужно было создать 100 и указать новую цену для них. Чтобы не делать этого руками, решили внедрить данный функционал. 
Отмечу, при копировании требовалось изменить лишь цену и ещё какой-то параметр и всё.

При обсуждении решений с другим разработчиком (пусть будет Олег), вышло так, что забавно, что он выступал за "ориентацию требований", когда как я выступал за "идентификацию поломок".

## с т.зр. онтологии, ориентированной на требования 

Олег предлагал следующее решение: создадим сущность template, как в коде, так и в СУБД в виде отношения.  
Template в виде отношения содержал все атрибуты, присущие тарифам (что означало большое количество null-значений).
При копировании тарифа, достаточно было выбрать шаблон и восполнить пустые поля. При изменении шаблона изменялись бы все атрибуты тарифов, ссылающиеся на этот шаблон.

## с т.зр. "идентификации поломок"

Мне решение это не понравилось по следующим причинам:
1) большое количество null-значение
2) если нужно создать новый экзмепляр template на основе существующего, то либо придется делать alter table, либо это невозможно
3) топорная реализация ориентированная на сущности, которые можно устранить (копироваание не есть существительное, ООАП -- 3 курс).
4) если потребуется установить ограничения на изменение атрибутов, то придется писать либо дополнительный код, либо триггер 
5) зависимость от шаблона. Представьте, что пользователь на основе шаблона Ш1 создал тарифы Т1,Т2...TN, и тариф Т`. Что если нам потребуется изменить все тарифы за исключение T`?
Изменяя шаблон, мы изменим все тарифы. В таком случае придется руками обновлять тарифы Т1,Т2...TN.

Как я рассуждал на тот момент. 
Что такое копирование с изменениями? Это выбор образца, выявление неизменяемых атрибутов (которые копируем), внесение значений в изменяемые атрибуты и создание (тобишь запись в БД).
Явно вырисовывается поток вычислений, и, казалось бы, можно сказать, что это просто механизм, и сущность Template нам вовсе не нужна. Но каким может быть копирование (как в случае с адресом)? Это может быть
поэтапное копирование, когда пользователь постепенно выбирает шаблон (на основе даты, названия и иных атрибутов тарифа) и сохраняет его. И вот тут сущность template уже может понадобиться. 
Но как отразить template в системе, минимизируя зависимость? Сущность template в случае поэтапного копирования можно сохранить в сессии пользователя. 

Чем копирование не является? 
1) Полное копирование тарифа (когда мы копируем все), тем самым выявили инвариант.
2) Новосозданные тарифы НЕ зависят от тарифа-образца, тем самым устраняя зависимость и будущие проблемы.

Модель копирования можно разделить на два этапа в данном случае: сохранение состояния (которые сохраняется в сессии пользователя) и непосредственный механизм копирования (создал процедуру в СУБД). 

## Свои мысли

На что я обратил бы внимание, так это на то, чем копирование НЕ является. В первом случае это создание явной зависимости между новосозданным тарифом и шаблоном, когда как во втором случае 
новосозданный тариф и тариф-образец - независимые сущности. Я не хочу сказать, что Олег предложил ужасное решение. Ключевую роль тут играет контекст. Тарифы - сущности самостоятельные, и изменение одного тарифа не должно влиять на другие.
И копирование именно подразумевает отсутствие зависимости между родителем и дочерним экземпляром. Решение Олега было бы замечательным, где требовалось бы создать конфигурацию для тарифов, где при изменении конфигурации менялись бы
соответствующие тарифы.


# Случай 2

Разработка механизма аггрегации метрик. Метрики делятся на типы, и аггрегация между типами может варьироваться.

## с т.зр. онтологии, ориентированной на требования

Имеются метрики Gauge и метрики Counter. 
Counter-метрики при аггрегации возвращает три максимальных значений каждой из Counter-метрики за определенный промежуток времени. Для этого хорошо подойдет куча.
Gauge-метрики при аггрегации возвращают последнюю установленную за определенный промежуток времени Gauge-метрику. Тут можно использовать мапу по метрики и заменять
значение по ключу в случае, если пришло установленное время больше текущего значения по ключу.

## с т.зр. "идентификации поломок"

Аггрегация метрик вне зависимости от типа может происходить как-угодно -- взять среднее, медиану и т.п. и кажется, что достаточно реализовать контейнер, реализующий аггрегацию.
Но дейсвитетльно "среднее Counter-метрики" подразумевает тоже самое, что и "среднее Gauge-метрики"? Среднее может определяться не просто "сумму на количество", но и иметь дополнительные
условия. Возможно, среднее подразумвается "среднее за период" или "среднее в пределах [a,b]" и делать единых механизм для разных типов данных, несмотря на один их источник, мне видится не лучшим вариантом.

## Свои мысли

Как видно, несмотря на "схожесть" различных типов метрик, будь то Gauge или Counter, взаимодействие с ними может различаться. В первом случае я шел от требований (нужна аггрегация такого типа метрик по такому механизму):
подобрал нужные структуры данных, реализовал методы интерфейса и готово.
Во втором случае же я столкнулся с последствиями, игнорирование которых вышло бы мне хоть и не боком, но усложнило бы кодовую базу.



# Случай 3

Механизм маршрутизации СМС-ок.
Требуется создать механизм маршрутизации СМС-ок в зависимости от текста и типа СМС.
Для отправки СМС, она хранится в кортеже, который хранит метаданные и сам текст СМС,

СМС-ки разделяются на "информационные", "развлекательные", "рекламные" и т.д.

## с т.зр. онтологии, ориентированной на требования

Для создания механизма маршрутизации можно использовать мапу, где ключ будет тип СМС-ки, а значение -- канал, куда она отправляется.
Таким образом по метаданным можно определять "адресата" СМС-ки. 

## с т.зр. "идентификации поломок"

Неизвестно, а могут ли СМС-ки быть и "информационными", и "развлекательными"? Если да, то придется ли дважды отправлять одну СМС? 
А если нет, то в какую из категорий ее отправлять? Как механизм должен разрешать данную проблему? Для аналитиков это может быть критически важной информацией.
Если СМС-ки может быть нескольких типов, то стоит в метаданных указать, имеет ли СМС один тип или комбинированный.

## Свои мысли

Пример невероятно тривиальный, но на работе это сыграло важную роль, поскольку уйти от реализации по требованиям к "идентфикации поломок" в постоянно работающем Erlange было бы очень сложно.



# Случай 4

Создать механизм экстраполяции прибыли на основе данных оборота, выручки и издержек последних  трех месяцев.

## с т.зр. онтологии, ориентированной на требования

Требования выдвигают точно описанный алгоритм, который достаточно привести в код. Вместе с аналитиком достаточно рассмотреть краевые случае для математической формулы рассчета.

## с т.зр. "идентификации поломок"

...

## Мои мысли

Онтология в данном случае не даст ничего нового, поскольку у нас имеется четкий механизм экстраполяции, а контекст использования -- единый, т.е. алгоритм, разработанный аналитиком,
не может быть применен вне нашей системы (точнее его не существовало вне нашей системы).

# По итогу

Теперь я знаю, как называется мое мышление, которое с детства присуще мне -- максимальная точная формализация всевозможных компонентов системы (необязательно программной). Это схема, как мне кажется, лучше подходит для продуктовой разработки, 
когда система непосредственно взаимодействует с внешним миром: вам есть от чего отталкиваться. Создаете систему для отправки посылок? Можно изучить предметную область, формализовать ее, учитывая контекст вашей системы, и разрабатывать.
Если речь идет исключительно требованиях, например, создать вычисление на основе прибыли предыдущих трех месяцев, то лучше понять, что из себя представляют участвующие в потоке вычисления компоненты, какие свойства и методы им присущи, и уже
на это "накладывать" данные нам требования. Такое мышление не раз помогало в карьере проявить себя и учесть краевые случаи, которые коллеги не уловили. Мне проще идти от того "что не должно быть", отсекать ненужные варианты. 
Что интересно, но применять подход "идентификации поломок", когда речь идет не о продуктовой разработке, а об абстракциях -- довольно сложно. Например, при создании операционных систем, мы не можем пойти по пути чистой онтологии, поскольку 
еще не знаем, что из себя будет представлять система, не существующей в реальном мире. Тут лучше идти по требованиям и "набивая шишки" возвращаться и переделывать. Эти два подхода не взаимоисключают, но дополняют друг друга.

Если проводить аналогию между требованиями и онтологией, то тут хорошо создание снежных фигур. Проектирование по требованию похоже на "изготовление" фигуры, которая будет наполнена снегом и получится снежная фигура, соответствующая требованиям
(точнее соответствующая тому, как мы эти требования формализовали). А вот онтология больше похоже на то, что если бы мы бы создали большой ком снега, имели бы представление о желаенмой фигуре и постепенно "отсекали" бы ненужные участки снега от кома.


Я бы отметил, что разбирал случаи в ретроспективе, то есть понимал, как они повлияли на продукт и как те или иные требования влияли на взгляд на программные сущности. От этого и примеры скудные на описание, поскольку "знаю как произошло".
