# Проектирование на микро-уровне

## Зависимость логической связи при работае двух программных компонентов

# Пример 1. Логическая зависимость.

Проект, который занимался сборкой метрик и хоста. Сервер принимал json-ы следующего вида:

```json
{
   "type": gauge|counter,
   "value" : nil, если type == gauge , иначе значение
   "delta" : nil, если type == counter, иначе значение
}
```
т.е gauge и counter два различных типа данных, которые, как мне кажется, стоит вынести в отдельные объекты.
Чтобы избежать в коде разветления, типа if type == gauge then ... и прочее, я создал тип данных interface Tupler, который реализовывали демаршализованные объекты из json'а.
Подход неплохой, но у него было ряд недостатков:
1) интерфейс не был функциональным, то есть содержал более одного метода
2) несмотря на то, что объекты, что gauge, что counter, инкапсулировали всю логику и интерфейсы уменьшали связность кода, разделить эти объекты нельзя было.
Например, я не мог получить список объектов типа gauge и другой список объектов типа counter. Тут либо плодить ещё один интерфейс, либо прибегать к другим приемам.

То есть задача -- разместить объекты в контейнеры, разделяя их по типу.
Как тут поможет прием инкапсуляции? В данном случае это не конечный результат, а отправная точка работы над дизайном, а именно разделение объектов по определенному свойству (в материале это было первые K сохранить, а остальные вернуть). 

Я создал функциональные интерфейсы Gauger и Counter с одним методом, дабы четко разделить типы объектов.
И вот допустим, нам надо вернуть контейнеры метрик, разделенных по типу. Выглядеть это будет следующим образом:

```go
func SplitMetrics(tuplerList TuplerList) (CounterList, GaugeList) { // CounterList и GaugeList  -- контейнеры, которые хранят Counter и Gauger инстансы соответственно.
   gaugeList := PutInGaugeList(tuplerList)  // создаем список с объектами, типа gauge
   counterList := PutInCounterList(tuplerList)// создаем список с объектами, типа counter
   return counterList, GaugeList)
}
```

Данный прием легко расширяется с помощью лямбд-функций-предикатов, которые могут задавать свойство разделения. Это очень похоже на функциональные fold, reduce, map. К тому же каждая строка соответствует SRP. 
Но один из мощнейших профитов, которые мы получим с данным приемом как раз переливается в следующий пример порядка списков.

# Пример 1. Важность порядков контейнеров

Как раньше я разделял объекты по типам? Получал строковое значение и через if-ы прогонял. Мне нужно было в отсортированном порядко по типу отправлять метрики другому приложению.
Теперь, инкапсулировав логику и получая списки с различными типами объектов, мне ничего не стоит сделать сортировку:

Было
```go
func (c Client) buildSend(url string, tuplerList TuplerList) {
  for tuplerList.Next() {
    curr := tuplerList.Val()
	  switch {
	  case curr.String() == "counter":
		  js, err := c.buildMarshalCounters(curr)
		  if err != nil {
			  log.Printf("%v", err)
  			return
		  }
  		c.send(url, js)
	  case curr.String() == "gauge":
		  js, err := c.buildMarshalGauges(curr)
		  if err != nil {
			  log.Printf("%v", err)
  			return
		  }
		  c.send(url, js)
	  }
  }
}
```

А стало:
Было
```go
func (c Client) buildSend(url string, tuplerList TuplerList) {
   gauges, counters := SplitMetrics(tuplerList)
   order := map[string]TuplerList{
    "gauge" : gauges,
    "counters" : counters
  }
  c.send(url, order["gauge"])
  c.send(url, order["counter"])
}
```

Но еще лучше вынести строение мапы с отдельный метод:

```go
func BuildOrderMap(tuplerList TuplerList) ma[string]TuplerList{
   gauges, counters := SplitMetrics(tuplerList)
   order := map[string]TuplerList{
    "gauge" : gauges,
    "counters" : counters
  }

  return order
}
```

Далее клиент принимает мапу и отправляет в нужном порядке, изменяя лишь порядок ключей.

# Пример 2. Логическая зависимость.

Следующий пример касается рассылки сообщений. Суть заключатся в следующим: компонент системы, написанный на Эрланге, принимал запрос об отправке N сообщений некоторому набору номера.
Была такая акция для клиентов, что при отправку от K сообщений, 5 или 10 процентов отправлялись случаный абонентам бесплатно. Бесплатные смски отправлялись после того, как были отправлены оплаченные сообщения.
Это проверялось ответом от СМС-центра.

Работало это следующим образом: когда клиент посылал запрос о рассылке сообщение, Эрланг-компонент отправлял смски смс-центру и ожидал получить все K отправленные смски, после чего отправлял бесплатную часть.
Проблема заключалась в том, что СМС-ки могли теряться/не отправиться/не пройти фильтры и прочее, из-за чего ожидание того, когда будут отправлены все СМС-ки могло доходить от нескольких часов, до нескольких дней, тем самым "пожирая" ОЗУ.

Получается такая задача: нужно отправить все смски клиента определенному кругу абонентов, а как все они были отправлены, отправить часть бесплатных СМС.
И почему подход из материала тут действительно хорош? Опять же, у меня получается увидеть не просто минорное изменение, а целое влияние на дизайн и принятие решений.
Во-первых, разделение логики объектов по свойству. В данном случае, это оплаченные смс-ки + бесплатные смс-ки в зависимости от платных.
Во-вторых, влияние на дизайн -- вместо того, чтобы ждать, пока все оплаченные смс-ки буду отправленны, мы можем инкапсулировать эту логику следующим образом:
1) создаем таблицу в БД, которая указывает на идентификатор запроса
2) оплаченные отправленные смски записываются в со статусом
3) в mnesia хранятся количество отправленных клиентов оплаченных смсок и количество отправленных смс-ок СМС-центром.
4) как только все смс-ки были отправлены смс-центром, мы вытаскиваем из БД оплаченные смски с текстом, типом и прочими характеристиками
5) на основе вытащенных оплаченных смс создаем бесплатные смс-ки и отправляем их остальным абонентам
6) мы логгируем какие бесплатные смски были отправлены на основе оплаченных

Такой дизайн гарантирует ясность в системе, где обращение к логам происходит каждый час. На что я прошу обратить внимание ,так это не на просто минорное изменение в коде, а опять же, на то, как изменяется поток вычислений и сам дизайн.

Я напишу псевдокод на Go, так как доступа к Эрланг коду у меня больше нет.

Было
```go
func SendSMSWithFree(msgs []Message) {
    count := len(msgs)
    receivedSuccess := 0
    
    SendToSMSCenter(msgs)
    // Ждем, пока не получим все успешно отправленные оплаченные смски
    for receivedSucess < count {
       received += GetSuccessSendedSMS()
    }

    freePart := count / 10
    freeMsgs := BuildFromPayedMsgs(msgs, freePart)
    SendToSMSCenter(freeMsgs)
    
    freePartReceived := 0
 	// Ждем, пока не получим все успешно отправленные бесплатные смски
    for freePartReceived < freePart {
       freePartReceived += GetSuccessSendedSMS()
    }
}
```


По сути нам нужно реализовать пункты 4,5 и 6. Станет это все выглядеть следующим образом:
```go
func SendSMSWithFree(msgs []Message, user User) ([]Message, []Message) {
     // Логика отправки сообщений
     SendToSMSCenter(msgs)

     // Получаем отправленные смс-ки СМС-центром
     sentPaymentSMS := db.Retrieve(user)
     // Создаем новые смски на основе отправленных пользователем
     freePaymentSMS := generateFreeSMS(sentPaymentSMS, user)

     SendToSMSCenter(freePaymentSMS)

     return sentPaymentSMS, freePaymentSMS
}
```

В случае, если нам потребуется определенный порядок логгирования, то...

# Пример 2. Важность порядков контейнеров


то мы можем сразу создать мапу и возвращать ее:
Было
```go
func SendSMSWithFree(msgs []Message, user User) ([]Message, []Message) {
     // Логика отправки сообщений
     SendToSMSCenter(msgs)

     // Получаем отправленные смс-ки СМС-центром
     sentPaymentSMS := db.Retrieve(user)
     // Создаем новые смски на основе отправленных пользователем
     freePaymentSMS := generateFreeSMS(sentPaymentSMS, user)

     SendToSMSCenter(freePaymentSMS)

     return sentPaymentSMS, freePaymentSMS
}
```

Стало
```go
func SendSMSWithFree(msgs []Message, user User) (map[string][]Message) {
     // Логика отправки сообщений
     SendToSMSCenter(msgs)

     // Получаем отправленные смс-ки СМС-центром
     sentPaymentSMS := db.Retrieve(user)
     // Создаем новые смски на основе отправленных пользователем
     freePaymentSMS := generateFreeSMS(sentPaymentSMS, user)

     SendToSMSCenter(freePaymentSMS)

      order := map[string][]Message{
    	"payment" : sentPaymentSMS,
         "free" : freePaymentSMS
  	}
    return order
}
```

Да, это выглядит надуманно, но в контексте Эрланга, где для этого будут существовать gen_server'ы и процессы, как мне кажется, выглядит очень хорошо.

# По итогу

Мне больше всего заинтересовал не сам момент инкапсуляции логики, от которой зависят композированные компоненты, как например с числом сообщений или видом метрик, а то, как происходит разделение между в виде контейнеров.
Во-первых, выносить какой-то параметр, от которых зависят потоки вычислений мне кажется естественным, дабы изменить код в одном месте и не забыть изменить в другом, кажется естественным делом.
Во-вторых, разделение потока вычислений. Это наиболее сильная фишка данного материала, как мне показалось. Дело в том, что разделяя поток вычислений для различных типов данных, мы тем самыми делаем их независимыми и легко-тестируемыми. Согласитесь, если метрики удовлетворяют одному интерфейс Tupler, то проверить все виды метрик на основе того,
что они реализуют Tupler нетривиальная задача, поскольку это нам говорит не особо много. Но если метрика Gauge имплементирует также Gauger интерфейс, это скажет нам много больше. Справедливо можно возразить, что разделяя таким способ поток вычислений и создавая тем самым более специализированные интерфейсы, код становится менее полиморфным.
(пока писал, вспомнил материал про юнит-тесты, что все инстансы для Tupler'а нужно тестировать корректное поведение, относительно Tupler'a). 
И все же, выделяя для каждого случая отдельный поток вычислений, мы тем самым следуем SRP (один поток -- одна логика над одними типами данных). Благо Go позволяет возвращать несколько значений.

А вот касательно мап и порядка возвращения -- это просто крутая фишка, особенно когда в качестве ключа будут кастомные константы. А еще лучше сделать оберку для мапы. 

Несмотря на то, что материал говорит о микро-изменениях в коде, это колоссальное улучшение в плане дизайна. Те, кто знаком с ФП это покажется естественным и более элегантным.
