# Проектирование на микро-уровне

## Зависимость логической связи при работае двух программных компонентов

# Пример 1. Логическая зависимость.

Проект, который занимался сборкой метрик и хоста. Сервер принимал json-ы следующего вида:

```json
{
   "type": gauge|counter,
   "value" : nil, если type == gauge , иначе значение
   "delta" : nil, если type == counter, иначе значение
}
```
т.е gauge и counter два различных типа данных, которые, как мне кажется, стоит вынести в отдельные объекты.
Чтобы избежать в коде разветления, типа if type == gauge then ... и прочее, я создал тип данных interface Tupler, который реализовывали демаршализованные объекты из json'а.
Подход неплохой, но у него было ряд недостатков:
1) интерфейс не был функциональным, то есть содержал более одного метода
2) несмотря на то, что объекты, что gauge, что counter, инкапсулировали всю логику и интерфейсы уменьшали связность кода, разделить эти объекты нельзя было.
Например, я не мог получить список объектов типа gauge и другой список объектов типа counter. Тут либо плодить ещё один интерфейс, либо прибегать к другим приемам.

То есть задача -- разместить объекты в контейнеры, разделяя их по типу.
Как тут поможет прием инкапсуляции? В данном случае это не конечный результат, а отправная точка работы над дизайном, а именно разделение объектов по определенному свойству (в материале это было первые K сохранить, а остальные вернуть). 

Я создал функциональные интерфейсы Gauger и Counter с одним методом, дабы четко разделить типы объектов.
И вот допустим, нам надо вернуть контейнеры метрик, разделенных по типу. Выглядеть это будет следующим образом:

```go
func SplitMetrics(tuplerList TuplerList) (CounterList, GaugeList) { // CounterList и GaugeList  -- контейнеры, которые хранят Counter и Gauger инстансы соответственно.
   gaugeList := PutInGaugeList(tuplerList)  // создаем список с объектами, типа gauge
   counterList := PutInCounterList(tuplerList)// создаем список с объектами, типа counter
   return counterList, GaugeList)
}
```

Данный прием легко расширяется с помощью лямбд-функций-предикатов, которые могут задавать свойство разделения. Это очень похоже на функциональные fold, reduce, map. К тому же каждая строка соответствует SRP. 
Но один из мощнейших профитов, которые мы получим с данным приемом как раз переливается в следующий пример порядка списков.

# Пример 1. Важность порядков контейнеров

Как раньше я разделял объекты по типам? Получал строковое значение и через if-ы прогонял. Мне нужно было в отсортированном порядко по типу отправлять метрики другому приложению.
Теперь, инкапсулировав логику и получая списки с различными типами объектов, мне ничего не стоит сделать сортировку:

Было
```go
func (c Client) buildSend(url string, tuplerList TuplerList) {
  for tuplerList.Next() {
    curr := tuplerList.Val()
	  switch {
	  case curr.String() == "counter":
		  js, err := c.buildMarshalCounters(curr)
		  if err != nil {
			  log.Printf("%v", err)
  			return
		  }
  		c.send(url, js)
	  case curr.String() == "gauge":
		  js, err := c.buildMarshalGauges(curr)
		  if err != nil {
			  log.Printf("%v", err)
  			return
		  }
		  c.send(url, js)
	  }
  }
}
```

А стало:
Было
```go
func (c Client) buildSend(url string, tuplerList TuplerList) {
   gauges, counters := SplitMetrics(tuplerList)
   order := map[string]TuplerList{
    "gauge" : gauges,
    "counters" : counters
  }
  c.send(url, order["gauge"])
  c.send(url, order["counter"])
}
```

Но еще лучше вынести строение мапы с отдельный метод:

```go
func BuildOrderMap(tuplerList TuplerList) ma[string]TuplerList{
   gauges, counters := SplitMetrics(tuplerList)
   order := map[string]TuplerList{
    "gauge" : gauges,
    "counters" : counters
  }

  return order
}
```

Далее клиент принимает мапу и отправляет в нужном порядке, изменяя лишь порядок ключей.

# Пример 2. Важность порядков контейнеров

Следующий пример касается рассылки сообщений. Суть заключатся в следующим: компонент системы, написанный на Эрланге, принимал запрос об отправке N сообщений некоторому набору номера.
Была такая акция для клиентов, что при отправку от K сообщений, 5 или 10 процентов отправлялись случаный абонентам бесплатно. Бесплатные смски отправлялись после того, как были отправлены оплаченные сообщения.
Это проверялось ответом от СМС-центра.

Работало это следующим образом: когда клиент посылал запрос о рассылке сообщение, Эрланг-компонент отправлял смски смс-центру и ожидал получить все K отправленные смски, после чего отправлял бесплатную часть.
Проблема заключалась в том, что СМС-ки могли теряться/не отправиться/не пройти фильтры и прочее, из-за чего ожидание того, когда будут отправлены все СМС-ки могло доходить от нескольких часов, до нескольких дней, тем самым "пожирая" ОЗУ.

Получается такая задача: нужно отправить все смски клиента определенному кругу абонентов, а как все они были отправлены, отправить часть бесплатных СМС.


Было
```go
```

Стало
```go
```

# Пример 2. Важность порядков контейнеров

Было
```go
```

Стало
```go
```
# По итогу
