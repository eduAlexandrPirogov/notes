# Как выбесить интервьюера (1)

Если такой случай, когда нужно было слить интервьюера и представлялся/будет представляться, то я не лезу в темы, где нужно математическое доказательсво, 
несмотря на то, что в по теории университетской математике и прочих дисциплин стояло "отлично". Практика отсутствует, вот и подзабыл :)

Я больше иду в темы, которые некоторыми считаются за "панацею" (как SOLID), но на самом деле это широкое поле для дискуссий. 
С SOLID'a и начну:

# Пример 1

Разговоры об SRP. С функциональной точки зрения мне проще рассуждать о данном принципе -- каждая функция делает что-то одно.
С ООП ситуация интереснее -- обычно после собеса, когда наступает моя череда "задавать вопросы", то частенько интервьюер слышит от меня "как вы создаете класс/пакет".
Этот вопрос частенько ставит в небольшой шок и первое, что слышится "Ну как как....как-то". И вот тут можно спросить сходу про SRP, мол как вы создаете вашу кодовую базу,
если вы не задаетесь вопросом, "а что собственно будет делать создаваемый компонент?".

Могут ответить, что SRP -- вещь неоднозначная и скинуть статью с хабра про синглтон и SRP https://habr.com/ru/articles/330142/, мол SRP можно нарушать, ничего страшного.
Тогда достаточно прийти к консенсусу и сказать, что у вас, как минимум, есть понимание об SRP.
Если же интервьюер настаивает на 100% соблюдении SPR, о можно спросить "почему вы тогда не пишите на ФП?". Или можно спросить "имеется ли у вас классы, у которых больше 7 публичных методов?".

# Пример 2

Разговоры про LSP.
C LSP намного проще ввести в ступор интервьюера. Нарушение LSP легко показать на числах, когда подкласс ослабляет предусловия или усиляет пост-условия. 
Если вам "завалили" или пытаются слить, то советую увести в эту тему и спросить интервьюера, насколько он хорошо понимает данный принцип, но, дополните, что в методе переданы не примитивные типы
данных, а интерфейсы. Тут можно вспомнить один из прошлых материал СИ по тестам и LSP)
Именно этим примером я воспользовался, когда на одном из собесов мне пыталилсь сбить ЗП.

# Пример 3

Важность обосновать свой ответ.
Иногда желательно не стольку "ткнуть мордой" интервьюера, сколько не дать "ткнуть мордой" себя. 

На одном из собесов меня спросили, что будет со следующим кодом:

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    runtime.GOMAXPROCS(1)

    done := false

    go func() {
        done = true
        fmt.Println("done")
    }()

    for !done {
    }
    fmt.Println("finished")
}
```

Вопрос на знание известных констант в Go. Я дал ответ, что программа выполнится, когда как на самом деле программа выдала timeout. Меня пожурили, мол "молодой человек, известная константа, надо знать!".
Но, изучив работу ОС, я обосновал свой ответ следующим образом: по аналогии с шедулером в ОС, несмотря на то, что GOMAXPROCS =  1 ( я думал, что это константа говорит об одновременно используемых ядрах),
программа исполнится нормально, так как шедулер просто будет менять потоки Go-шки. Логический шедулер в Go и шедулер в ОС очень похожи, но вот с такой разницей.
Интервьюер согласился, что мои рассуждения верны, а ситуация -- специфична.

Касательно знания констант, то нужно не стесняться говорить "проверяю в документации значение константы".

# Пример 4

Последняя тема -- реляционная модель.
Этим можно воспольззовать на секции System Design, когда просят спроектировать схему их n отношений. Зачастую времени "усмотреть" все краевые случаи не хватит,
а интервьюер все равно сможет за них спросить. Если атмосфера токсична и вам вменяют "незнание нормальных форм", то можно смело обозначать свою позицию касательно нормальных форм не как 
"заучивание определений",а со стороны как раз-таки реляционной модели. Например, достаточно сказать, что 2 и 3 нормальных формы можно легко понять со стороны функциональной и многозначеной зависимости
(да, многозначная зависимость есть частный случай функциональный, но наврядли интервьюер это знает) и на основе этих знаний вы спроектировали схему отношений.

Также можно "зацепиться" за первую нормальную форму. Если вспомнить книгу "Реляционная модель" (автора забыл), то, прежде всего, первая нормальная форма говорит о домейне, и от домейна идет атомарность. 
Например, у нас есть отношение с одним атрибутом, который хранит кортеж вида {Number, String}. Нарушение первой нормальной формы? А что если наш домейн -- кортежи данного вида? :)


# По итогу

У меня было пару токсичных интервью в этом году и лишь на одном из них я позволил себе "ткнуть мордой" интервьюера. Не сказать, что жалею, но лучшим вариантом, если вам не повезло с собеседованием и 
явно ощущается неприятная атмосфера, пытаются сбить вашу ценность, будет просто завершить собеседование. Так вы сэкономите и время, и нервы. Плюс сохраните репутацию в круге HR-ов как спокойного кандидата.
Но есть ситуации, когда вам стоит остаться и отстаивать свою точку зрения, даже если вам вменяют, что вы не правы. Так натренируется навык переговоров без страха.

# Не совсем в тему, но про умение отстоять свою точку зрения

При устройстве в Яндекс на очередном этапе мне дали следующую задачу:

```
// Дана строка, состоящая из букв 'X', 'Y' и 'O'. 
// Необходимо найти кратчайшее расстояние между буквами 'X' и 'Y', либо вывести 0, если 'X' либо 'Y' отсутствуют.

// "YY" -> 0
// "XX" -> 0
// "XY" -> 1
// "YOX" -> 2
// "OOOXOOYOXO" -> 2
// "OOOXXOY"-> 2
```

 Интервьюер недоумевал, как я не смог решить эту задачу императивно. А мое решение "на словах" он не принимал, так как было "слишком сложно". Но действительно ли это так сложно?
Мое решение таково. Строка -- по сути список байтов. Список -- рекурсивная структура данных. Мое решение было функциональном и алгоритм невероятно был прост:
1) Ищем первый символ X или Y
2) Ищем следующим противоположный символ.
3) Как только нашли противоположный символ, в аккумуляторе обновляем перемнную длины (устанавливаем минимальную длину)
4) Дойдя до конца списка, возвращаем аккумулятор

Сам код состоял бы из 3 случаев для функций
1) Когда строка пустая
2) Когда строка не пустая и не нашли один из искомых символов ищем один из искомых символов в "хвосте" строки
3) Когда строка не пустая, нашли искомый символ и ищем противоположный символ в "хвосте" строки

Так я отстоял свое решение. Осознав его, интервьюер сказал, что "это невероятно красивое" (на фп видимо не программировал).  Но в Яндекс я так и не прошел :)
