# Избавляемся от stateful через глобальное состояние

За последние 1.5 года мой стиль написания кода у меня сформировался таков, что в основном пишу функционально и выносил все локальные состояния в глобальные переменные. Делал это неосознанно в плане
до момента изучения данного материала.
На первой работе, где работал с экстраполяцией финансовых показателей например все коэффициенты и расчеты перемещались в глобальные переменные как константы (но после прочтения заметки, я бы их 
вынес в .env-подобный файл), поскольку модель вычисления данных была следующей: у нас имелись входные данные, которые проходили через алгоритм рассчета экстраполяции и результат сохранялся в БД.
Логика довольна проста (проста кстати благодаря остутствию stateful), состояния встречаются уж совсем минимум -- они вынесены либо в глобальные перееменные, либо в .env файле, либо в БД.
Работая сейчас Erlang разработчиком, ситуация аналогична. То есть, у меня имеется некоторый опыт "избегания" stateful и смотреть в сторону stateless.

Мои мысли по поводу вынесения stateful таковы: это очень крутая идея, которая наврядли будет восприниматься радужно. Приведу доводы в сторону stateless (неважно каким способ он достигнут, будь-то
вынесение в const глобальные переменные, или же будь это внешний мир):
1) На каждый интерфейсный метод у нас будет один поток вычислений, поскольку мы используем stateless (и следовательно неизменяемые ячейки). Используя stateful мы делаем поток вычислений зависимым
от состояний. Ну, например:

```go
func (d *DefaultHandler) processUpdateCounter(metric metrics.Metrics) ([]byte, int) {
	if metric.Delta == nil || metric.Value != nil {
		return []byte{}, http.StatusBadRequest
	} 
		d.DB.Write(metric.MType, metric.ID, fmt.Sprintf("%d", *metric.Delta))
		body, err := d.DB.ReadByParams(metric.MType, metric.ID)
		if err != nil {
			log.Printf("err while read after write %v metric: %s %s", err, metric.MType, metric.ID)
		}
		return body, http.StatusOK
}
```

У DefaultHandler имеется состояние DB для взаимодействия с БД. Чем это плохо?
1) имеем состояние, от которого зависит корректность всех вычислений. Сломал мутабельную DB мы ломаем все вычисления.
2) У нас формируется модель "многие-к-одному", когда все вычисления сходятся к одному состоянию. Если, например, мы хотели бы записывать данные в Mongo, например, то придется создавать доп
поле в структуре, написывать if-ы и прочее усложнения. Это кстати можно избежать следующим образом: мы выносим подключение либо в синглтон, либо в константу, если язык позволит. А методы обращения
к БД будут выглядеть следующим образом:

```go
// Write writes tupler to DB and return written state
//
// Pre-cond: given tuples to Write in given Storer
//
// Post-cond: if was written successfully returns NewTuple state and error nil
// Otherwise returns emtyTuple and error
func Write(s Storer, state tuples.Tupler) (tuples.Tupler, error) {
	newState, err := s.Write(state)
	if err != nil {
		return nil, err
	}

	return newState, nil
}
```
 
Теперь у нас имеется Storer -- подключение к БД, которые мы вынесем в глобальные переменные. У нас получается связь "многие-ко-многим", но не в смысле реляционной модели, а в плане, что 
многие потоки вычислений соотносятся к многим независимым иммутабельным ячейкам. 

2) Второй довод в пользу stateless -- забыть что такое дебаггер :)

Вообще, меня мучил вопрос "можно ли целиком уйти от statefull?", а точнее, насколько эффективно будет уход в stateless, и речь не об скорости вычислений, а в целом: поддержка кода, скорость
написания новых фич, изменение и прочее. Вынося например состояния даже просто в файлы, возникает вопрос чтения/валидации, а также обновление состояния "на лету". В Erlang это сделаон очень 
удобно и просто, но если брать иные языки, не придется ли перезапускать приложение, чтобы обновить состояние? Можно также сказать про относительно тяжелые операции ввода-вывода для обновления/
чтения состояния, но зависит от контекста сильно. Насколько опять же подобный подход воспримут коллеги (например, на текущей работе, где есть Java, это точно будет отвергнуто).

По итогу могу сказать, что я подчерпнул для себя две вещи: вынесение состояний в внешний мир или же в отдельную систему (та же БД), а не просто в глобальные константы. 
Возможно я слишком сильно привык писать в декларативном стиле, и для меня это выглядит не в новинку .  
