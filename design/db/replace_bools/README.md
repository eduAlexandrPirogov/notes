# Хранение логических значений в БД

Пример 1

Суть проекта заключается в ведение отчетов по изученным темам, концепция как у гитхаба. То есть существуют 
процессы (аналог репозиториям) с тредами (аналог ветвей) и квантами (аналог коммитов). Пользователь создает новый процесс
по изучаемой теме, и разбивает тему на потоки (например, теоретическая часть и практическая). 
Изучив концепцию из темы, пользователь создает квант (аналог коммита и гитхаба, и аналог твита из твиттера).
Прежде чем изучить тему, пользователь должен будет создать план, схема которых приведена ниже:

```sql
CREATE TABLE SHEETS(
    ID SERIAL PRIMARY KEY,
    TITLE VARCHAR(300),
    PROC_ID INT NOT NULL,
    CONSTRAINT fk_sheets_proc FOREIGN KEY(PROC_ID) REFERENCES PROCESSES(ID)
);

CREATE UNIQUE INDEX sheets_proc_id_unique ON SHEETS (PROC_ID);

CREATE TABLE SHEETS_CONTENT(
    ID SERIAL PRIMARY KEY,
    SHEETS_ID INT NOT NULL,е
    THEME VARCHAR(500),
    DATE DATE,                #планируемая дата, когда тема будет изучена
    DONE BOOLEAN DEFAULT FALSE,   #завершил ли изучение темы пользователь
    CONSTRAINT fk_content_sheets FOREIGN KEY(SHEETS_ID) REFERENCES SHEETS(ID)
);
```

SHEETS -- таблица плана для процесса, а SHEETS_CONTENT --  содержимое контента. Для просто, можно представить, что 
план выглядит как гугл-эксель. 
SHEETS_CONTENT -- содержит поле DONE, которое указывает, закончил ли пользователь изучение темы. 

Поле DONE действительно можно заменить на тип данных DATETIME, что принесет нам следующие преимущества:
1) это даст неявный дополнительный функционал. Например, мы можем вычислить разницу между DATE и DONE, что позволит вести статистику
2) мы полноценно можем избавить от if-ов в коде. При создании темы, дату DONE можно поставить равной DATE, тем самым избегая NULL значений.
При завершении изучении темы, пользователь может вернуться к ней, и каждый раз DONE будет просто обновляться на новую дату, а не с 
true на true, как это было бы в первом случаее


Новый вариант:

```sql
CREATE TABLE SHEETS_CONTENT(
    ID SERIAL PRIMARY KEY,
    SHEETS_ID INT NOT NULL,е
    THEME VARCHAR(500),
    DATE DATE,                #планируемая дата, когда тема будет изучена
    DONE DATE,            #фактическая дата, когда тема была изучена
    CONSTRAINT fk_content_sheets FOREIGN KEY(SHEETS_ID) REFERENCES SHEETS(ID)
);
```

Пример 2

Очень частый пример, который я встречаю как на консультациях, так и на работе. Это даже метапример, суть которого заключается в следующем:
имеется некоторая сущность, дату создания которой мы отслеживаем, обычно это created_at. Наряду с created_at, имеются булевы поля, которые
легко заменить. Рассмотрим конкретный пример.
Часто наблюдал, как некоторый конфиг сущности хранят в подобном виде:

```sql
CREATE TABLE REFL_AUT_CONFIG(
    ID SERIAL PRIMARY KEY,
    USER_ID INT,
    ... # конфиг либо хранится в одном json поле, либо в 20+ столбцах, не суть важно
    CURRENT BOOLEAN, # выбрал ли пользователь текущую конфигурацию
    CREATED_AT TIMESTAMP,
    CONSTRAINT fk_tac_users FOREIGN KEY(USER_ID) REFERENCES USERS(ID)
);
```

Зачастую пользователь имеет несколько конфигов, и лишь единственный является текущим (CURRENT). 
Тут проблема в том, что либо нужно писать триггер, проверяющий инвариант "для каждого пользователя лишь единственный конфиг CURRENT, 
может равняться true". Это ипросто, но дорого. Упростить можно следующим образом:

```sql
CREATE TABLE REFL_AUT_CONFIG(
    ID SERIAL PRIMARY KEY,
    USER_ID INT,
    ... # конфиг либо хранится в одном json поле, либо в 20+ столбцах, не суть важно
    CURRENT TIMESTAMP, # выбрал ли пользователь текущую конфигурацию
    CREATED_AT TIMESTAMP,
    CONSTRAINT fk_tac_users FOREIGN KEY(USER_ID) REFERENCES USERS(ID)
);
```

Когда пользователь меняет конфиг, то CURRENT ставит дату с временем now(). Чтобы выбрать текущий конфиг, достаточно выбрать 
max(current), и, что самое важное, наш инвариант никогда не будет нарушен! Физически невозможно, чтобы в БД у одного пользователя было два
конфига с одинаковой датой и временем (при условии, что пользователь взаимодействует с системой через некоторый интерфейс).

Пример 3

