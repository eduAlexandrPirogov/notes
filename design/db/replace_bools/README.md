# Хранение логических значений в БД

# Пример 1

Суть проекта заключается в ведение отчетов по изученным темам, концепция как у гитхаба. То есть существуют 
процессы (аналог репозиториям) с тредами (аналог ветвей) и квантами (аналог коммитов). Пользователь создает новый процесс
по изучаемой теме, и разбивает тему на потоки (например, теоретическая часть и практическая). 
Изучив концепцию из темы, пользователь создает квант (аналог коммита и гитхаба, и аналог твита из твиттера).
Прежде чем изучить тему, пользователь должен будет создать план, схема которых приведена ниже:

```sql
CREATE TABLE SHEETS(
    ID SERIAL PRIMARY KEY,
    TITLE VARCHAR(300),
    PROC_ID INT NOT NULL,
    CONSTRAINT fk_sheets_proc FOREIGN KEY(PROC_ID) REFERENCES PROCESSES(ID)
);

CREATE UNIQUE INDEX sheets_proc_id_unique ON SHEETS (PROC_ID);

CREATE TABLE SHEETS_CONTENT(
    ID SERIAL PRIMARY KEY,
    SHEETS_ID INT NOT NULL,е
    THEME VARCHAR(500),
    DATE DATE,                #планируемая дата, когда тема будет изучена
    DONE BOOLEAN DEFAULT FALSE,   #завершил ли изучение темы пользователь
    CONSTRAINT fk_content_sheets FOREIGN KEY(SHEETS_ID) REFERENCES SHEETS(ID)
);
```

SHEETS -- таблица плана для процесса, а SHEETS_CONTENT --  содержимое контента. Для просто, можно представить, что 
план выглядит как гугл-эксель. 
SHEETS_CONTENT -- содержит поле DONE, которое указывает, закончил ли пользователь изучение темы. 

Поле DONE действительно можно заменить на тип данных DATETIME, что принесет нам следующие преимущества:
1) это даст неявный дополнительный функционал. Например, мы можем вычислить разницу между DATE и DONE, что позволит вести статистику
2) мы полноценно можем избавить от if-ов в коде. При создании темы, дату DONE можно поставить равной DATE, тем самым избегая NULL значений.
При завершении изучении темы, пользователь может вернуться к ней, и каждый раз DONE будет просто обновляться на новую дату, а не с 
true на true, как это было бы в первом случаее


Новый вариант:

```sql
CREATE TABLE SHEETS_CONTENT(
    ID SERIAL PRIMARY KEY,
    SHEETS_ID INT NOT NULL,е
    THEME VARCHAR(500),
    DATE DATE,                #планируемая дата, когда тема будет изучена
    DONE DATE,            #фактическая дата, когда тема была изучена
    CONSTRAINT fk_content_sheets FOREIGN KEY(SHEETS_ID) REFERENCES SHEETS(ID)
);
```

# Пример 2

Очень частый пример, который я встречаю как на консультациях, так и на работе. Это даже метапример, суть которого заключается в следующем:
имеется некоторая сущность, дату создания которой мы отслеживаем, обычно это created_at. Наряду с created_at, имеются булевы поля, которые
отражают некоторый предикат, который легко заменить. Рассмотрим конкретный пример.
Часто наблюдал, как некоторый конфиг сущности хранят в подобном виде:

```sql
CREATE TABLE REFL_AUT_CONFIG(
    ID SERIAL PRIMARY KEY,
    USER_ID INT,
    ... # конфиг либо хранится в одном json поле, либо в 20+ столбцах, не суть важно
    CURRENT BOOLEAN, # выбрал ли пользователь текущую конфигурацию
    CREATED_AT TIMESTAMP,
    CONSTRAINT fk_tac_users FOREIGN KEY(USER_ID) REFERENCES USERS(ID)
);
```

Зачастую пользователь имеет несколько конфигов, и лишь единственный является текущим (CURRENT). 
Тут проблема в том, что либо нужно писать триггер, проверяющий инвариант "для каждого пользователя лишь единственный конфиг CURRENT, 
может равняться true". Это ипросто, но дорого. Упростить можно следующим образом:

```sql
CREATE TABLE REFL_AUT_CONFIG(
    ID SERIAL PRIMARY KEY,
    USER_ID INT,
    ... # конфиг либо хранится в одном json поле, либо в 20+ столбцах, не суть важно
    CURRENT TIMESTAMP, # выбрал ли пользователь текущую конфигурацию
    CREATED_AT TIMESTAMP,
    CONSTRAINT fk_tac_users FOREIGN KEY(USER_ID) REFERENCES USERS(ID)
);
```

Когда пользователь меняет конфиг, то CURRENT ставит дату с временем now(). Чтобы выбрать текущий конфиг, достаточно выбрать 
max(current), и, что самое важное, наш инвариант никогда не будет нарушен! Физически невозможно, чтобы в БД у одного пользователя было два
"текущих" конфига с одинаковой датой и временем (при условии, что пользователь взаимодействует с системой через некоторый интерфейс), 
поскольку пользователь за одну единицу времени может выбрать один текущий конфиг!
Плюс это дает следующую гибкость -- вы можете определить, который конфиг использовал пользователь в некотором месяце (опять же по CURRENT).

# Пример 3

Вспомнился еще студенческий проект. Создавал проект, который помогал бы организовывать футбольные турниры. Тут интересует следущее
отношение:

```sql
CREATE TABLE TOURNAMENT(
    ID SERIAL PRIMARY KEY,
    TITLE VARCHAR(300),
    START_DATE TIMESTAMP,
    IS_APPROVED BOOLEAN DEFAULT FALSE #подтвержено ли проведение турнира
);
```

Суть такова, что при создании турнира, он должен соответствовать некоторым условиям, и его должны подтвердить. 
Например, на турнире участвует достаточное количество команд, или должно быть определенное количество команд из каждой лиги.
И если турнир подтвержден, то IS_APPROVED должен стоять true.

IS_APPROVED, на тот момент мне нужен был для того, чтобы я мог найти турниры, которые не подтвердили (например, вопрос его 
проведения еще рассматривают). Избавиться от IS_APPROVED, и создать отдельную таблицу TOURNAMENT_REQUESTS, которая бы хранила заявки на участие турнира. Таким образом, мы явно разделяем логику "заявку на турнир и турнир". Суть в том, что необязательно заменять
булево значение на иное, его можно выразить в другом отношении. Например, если в проведении турнира будет отказано, то неплохо было бы
хранить причину отказа.

# По итогу

Это дико крутая фишка, которую я уже использую в своих проектах. Одна из главных проблем, которая встречается в булевых значениях, как 
по мне, это сохранение инвариантов на уровне БД -- это либо триггеры, либо дополнительные ассерты на уровне DDL. Если потребуется расширить
отношение некоторым атрибутом, то логическое значение будет нарушать 3НФ. А за счет выражения логического выражения в некотором ином виде,
можно прийти как к более простому способу соблюдения инварианта, так и к более гибкой системе :)
