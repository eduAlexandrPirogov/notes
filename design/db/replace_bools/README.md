# Хранение логических значений в БД

Пример 1

Суть проекта заключается в ведение отчетов по изученным темам, концепция как у гитхаба. То есть существуют 
процессы (аналог репозиториям) с тредами (аналог ветвей) и квантами (аналог коммитов). Пользователь создает новый процесс
по изучаемой теме, и разбивает тему на потоки (например, теоретическая часть и практическая). 
Изучив концепцию из темы, пользователь создает квант (аналог коммита и гитхаба, и аналог твита из твиттера).
Прежде чем изучить тему, пользователь должен будет создать план, схема которых приведена ниже:

```sql
CREATE TABLE SHEETS(
    ID SERIAL PRIMARY KEY,
    TITLE VARCHAR(300),
    PROC_ID INT NOT NULL,
    CONSTRAINT fk_sheets_proc FOREIGN KEY(PROC_ID) REFERENCES PROCESSES(ID)
);

CREATE UNIQUE INDEX sheets_proc_id_unique ON SHEETS (PROC_ID);

CREATE TABLE SHEETS_CONTENT(
    ID SERIAL PRIMARY KEY,
    SHEETS_ID INT NOT NULL,е
    THEME VARCHAR(500),
    DATE DATE,                #планируемая дата, когда тема будет изучена
    DONE BOOLEAN DEFAULT FALSE,   #завершил ли изучение темы пользователь
    CONSTRAINT fk_content_sheets FOREIGN KEY(SHEETS_ID) REFERENCES SHEETS(ID)
);
```

SHEETS -- таблица плана для процесса, а SHEETS_CONTENT --  содержимое контента. Для просто, можно представить, что 
план выглядит как гугл-эксель. 
SHEETS_CONTENT -- содержит поле DONE, которое указывает, закончил ли пользователь изучение темы. 

Поле DONE действительно можно заменить на тип данных DATETIME, что принесет нам следующие преимущества:
1) это даст неявный дополнительный функционал. Например, мы можем вычислить разницу между DATE и DONE, что позволит вести статистику
2) мы полноценно можем избавить от if-ов в коде. При создании темы, дату DONE можно поставить равной DATE, тем самым избегая NULL значений.
При завершении изучении темы, пользователь может вернуться к ней, и каждый раз DONE будет просто обновляться на новую дату, а не с 
true на true, как это было бы в первом случаее


Новый вариант:

```sql
CREATE TABLE SHEETS_CONTENT(
    ID SERIAL PRIMARY KEY,
    SHEETS_ID INT NOT NULL,е
    THEME VARCHAR(500),
    DATE DATE,                #планируемая дата, когда тема будет изучена
    DONE DATE,            #фактическая дата, когда тема была изучена
    CONSTRAINT fk_content_sheets FOREIGN KEY(SHEETS_ID) REFERENCES SHEETS(ID)
);
```

Пример 2



Пример 3

