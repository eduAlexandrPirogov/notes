# Пример денормализации данных

Т.к. пример рабочий, DDL упрощен.

Изначально таблицы:

Сервисы: id, title, group_service_id.
Оффициальная Группа Сервисов: id, title
Пользовательские Группы Сервисов: id, title
Связь "многие-ко-многим", связывающая сервисы и пользовательские группы сервисов: service_id, user_define_group_id

Финансовые поступления на сервис: id, service_id, date (по дням), finance_type_1, finance_type_2....
Финансовые поступления из отчета: id, service_id, date (по неделям), finance_type_11, finance_type_21,...

Акции (некоторые бонусы, которые предоствляются сервисами. Длительность -- целые дни, то есть нет, чтобы были акции на пару часов): id, title, date_start, date_end. 
Связь акции_сервисы (многие-ко-многим): service_id, projit_id

-----
Для финансового отчета за месяц, связываются все таблицы через join'ы с условиями (в зависимости от предпочтений пользователя). Запросы на чтение частые
(несколько раз в минуту на инстанс продовой БД), запись -- раз в день, ночью.

-----

Поскольку данные нужны для финансовых аналитиков, тут хорошо бы подошла OLAP-система, но можно сделать немного иначе:

--DDL таблицы, ниже описаны, почему выбрана такая схема.
report(
id,
service,
official_group_service,
custom_group_service,
profits,
date,
service_finance_type1,......., report_finance_type11,


Получается следующее: я бы не отказывался от предыдущих таблиц, а сделал одну денормализованную по следующим причинам:
1) Запросы на чтение происходят намного чаще нежели запросы на запись.
2) Строить запросы (вьюхи) по просьбе аналитиков -- головная боль (множество join'ов с условиями).
3) Один раз заполнить подобную таблицу намного проще (запускается процедура в выходные, которые формирует для аналитиков подобную "портянку").

Важный момент, который тут имеется -- не столько вопрос производительности и верного проектирования, как вопрос изучения данных.

Например, сервис изучая годовой финансовый отчет сервиса, можно не сомневаться, что он "будет подвержен" различным акциям в некоторые интервалы времени.
Смотря на изначальную схемы таблиц, у нас имеются два объекта -- сервис и акция. Если аналитик, для примера, захочет посмотреть финансовый отчет, изменив
условия акции (скажем, скидка на покупку услуги/товара у данного сервиса увеличина на 50%). Но! Изменение этой акции должно коснуться только единственного сервиса,
а не всех.

Говоря более формально:
Имеется акция А1, с которой связаны сервисы множества С. Мы хотим узнать, как изменятся финансовые показатели, если для сервиса С1 из множества С акция А1 будет улучшена?
В реляционной изначальной модели придется либо усложнять запрос, либо отказаться от идеи, поскольку мы "шарим акции" посредством таблицы связи многие-ко-многим.

Деформализовав же таблицу, достаточно будет лишь обновить или (клонировать + обновить) строку.

-------------------

Лучше всего смысл данных, как их лучше смоделировать, можно понять, если смотреть со стороны MongoDB. Например, имеется коллекции Товары, Покупатели, Купоны.
И как лучше хранить нам данные: в одной коллекции, или в трех разных?

Тут вопрос важно поставить не только со стороны, какие операции будут воспроизводиться над данными (имеется ввиду, не запись или чтение;и не какие индексы установить), а также,
какая связь между данными. Например, мы собрали корзину из товаров, и хотим выбрать такой купон, чтобы выгода была максимальной.
Но что кого содержит? Товары содержат купоны, или купоны содержат товары?
Изменяются ли купоны со временем? А если у пользователя имеется два одинаковых купона на один товар с одной скидкой -- это один объект или два разных?

И тут, если эксереминтировать с mongo, можно получить некоторые общие шаблонные ответы на вопросы.
Например, если мы будем ссылаться на "купон", то его update влияет на все ссылающие на него объекты,и т.п.

--------------

На моделированние данных смотреть стоит не только со стороны типа отношения "1к1", "1кN" и т.д., но и со стороны мутабельности данных, а также операциями над данными, их видом и их отношениями.
То есть:
1) Определяем отношения
2) Определяем вид (мутабельные или нет)
3) Определяем операции, плюсы и минусы тех или иных операцих над теми или иными видами данных.

