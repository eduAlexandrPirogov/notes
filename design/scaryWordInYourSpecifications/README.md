# Страшное слово в спецификацияъ

# Пример 1

Одно из рабочих заданий заключалось в рассчете прибыли для сервиса со всеми скидками (что-то типа экстраполяции, чтобы выяснить на основе предыдущего опыта, какая скидка была наиболее прибыльной).
Были таблицы скидок, сервисов и таблица связи между скидками и сервисами.
В качестве одного из возможных решений было предложено просто добавить все скидки в связь для соответствующего сервиса, но в нем заключалась загвоздка: поскольку на скидку могло ссылаться несколько
иных сервисов, то нужна была возможность изменять скидку так, чтобы изменения распространялись лишь на сервис, для которого нужна экстраполяция, но для остальных бы скидка не изменялась.
Также был вариант сделать не в базе, а в памяти, где и рассчитывалось бы экстраполяция для сервиса со всеми скидками, с возможностью их модификации и просмотром в реальном времени, но без сохранения
изменения.
  
Я выбрал следующий путь -- создал отдельную таблицу, которая хранила ссылку на сервис, ссылку на скидку и коэффициент, который можно было бы изменять.

Структура таблицы:
|id|service_id|sale_id|coeff|
+--+----------+-------+-----+
|  |          |       |     |

Все информацию по сущностям можно было достать (по sale_id можно взять оригинальный коэффициент, например). Изменять coeff можно в данной таблицы, не опасаясь, что это заденет другие сервисы.
Позже, отношение было расширено двумя атрибутами `note`, `date` -- комментарий по коэффециенту и дате сохранения, чтобы можно было сохранять результаты.
Сам того не осознавая, и ограничил влияние всех скидок для конкретного случая.

# Пример 2

Также было заданий по реализации парсинга файла, который включал в себя квартальные отчеты по предоставленным услугам, ценам, скидкам, налогам и прочим финансовым показателям.
Тут стоит обратить внимание лишь на услуги: они разделялись на группы, у каждой был свой период действия, своя цена и иные характеристики.
К тому же, файл нужно было не только уметь парсить, но и аггрегировать, сортировать, предоставлять статистику.

Спецификация заключалась в следующем: ПО должно уметь аггрегировать услуги по показателям ...  и формировать указанную ниже статистику ...
В спецификации подразумевалось, что услуги по своей сути идентичны между собой. На деле, у некоторых услуг не было данных, у иных данные могли выходить за пределы инварианта и так далее.
Приходилось проверять файл и отправлять обратно по почте с указанными замечаниями. И вот задача превратилась не только в парсинг, но и в валидацию.

Теперь к сути. Во-первых услуги нельзя было отнести к одной категории, несмотря на их "похожесть" в файле. Во-вторых, услуги также можно было разделить на те, которые можно было посчитать, и те,
которые имели невалидные или недостаточно данных.

Реализация ПО сошлась к следующему: изначально я разделял услуги, которые можно посчитать и те, которые невалидны. Далее, в зависимости от конфигурации и флагов, формировались различные АТД для 
каждого типа услуг. Например, если нужно было сформировать отчет, который содержал сервисы от группы k, и записать в файл в порядке убывания по прибыли, то я создавал АТД очередь, в которую 
заносились АТД сервисы для АТД группы k (поскольку для каждой группы могли быть свои условия). 

У меня получилось более чем 100 классов по итогу, когда как спецификации подразумевали, что все услуги и методы по рассчетам почти идентичны. Естественно все нюансы выявлялись во время разработки.

# Пример 3

# Пример 4

# Пример 5
