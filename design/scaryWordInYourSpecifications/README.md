# Страшное слово в спецификацияъ

# Пример 1

Одно из рабочих заданий заключалось в рассчете прибыли для сервиса со всеми скидками (что-то типа экстраполяции, чтобы выяснить на основе предыдущего опыта, какая скидка была наиболее прибыльной).
Были таблицы скидок, сервисов и таблица связи между скидками и сервисами.
В качестве одного из возможных решений было предложено просто добавить все скидки в связь для соответствующего сервиса, но в нем заключалась загвоздка: поскольку на скидку могло ссылаться несколько
иных сервисов, то нужна была возможность изменять скидку так, чтобы изменения распространялись лишь на сервис, для которого нужна экстраполяция, но для остальных бы скидка не изменялась.
Также был вариант сделать не в базе, а в памяти, где и рассчитывалось бы экстраполяция для сервиса со всеми скидками, с возможностью их модификации и просмотром в реальном времени, но без сохранения
изменения.
  
Я выбрал следующий путь -- создал отдельную таблицу, которая хранила ссылку на сервис, ссылку на скидку и коэффициент, который можно было бы изменять.

Структура таблицы:
|id|service_id|sale_id|coeff|
+--+----------+-------+-----+
|  |          |       |     |

Все информацию по сущностям можно было достать (по sale_id можно взять оригинальный коэффициент, например). Изменять coeff можно в данной таблицы, не опасаясь, что это заденет другие сервисы.
Позже, отношение было расширено двумя атрибутами `note`, `date` -- комментарий по коэффециенту и дате сохранения, чтобы можно было сохранять результаты.
Сам того не осознавая, и ограничил влияние всех скидок для конкретного случая.

# Пример 2

Также было заданий по реализации парсинга файла, который включал в себя квартальные отчеты по предоставленным услугам, ценам, скидкам, налогам и прочим финансовым показателям.
Тут стоит обратить внимание лишь на услуги: они разделялись на группы, у каждой был свой период действия, своя цена и иные характеристики.
К тому же, файл нужно было не только уметь парсить, но и аггрегировать, сортировать, предоставлять статистику.

Спецификация заключалась в следующем: ПО должно уметь аггрегировать услуги по показателям ...  и формировать указанную ниже статистику ...
В спецификации подразумевалось, что услуги по своей сути идентичны между собой. На деле, у некоторых услуг не было данных, у иных данные могли выходить за пределы инварианта и так далее.
Приходилось проверять файл и отправлять обратно по почте с указанными замечаниями. И вот задача превратилась не только в парсинг, но и в валидацию.

Теперь к сути. Во-первых услуги нельзя было отнести к одной категории, несмотря на их "похожесть" в файле. Во-вторых, услуги также можно было разделить на те, которые можно было посчитать, и те,
которые имели невалидные или недостаточно данных.

Реализация ПО сошлась к следующему: изначально я разделял услуги, которые можно посчитать и те, которые невалидны. Далее, в зависимости от конфигурации и флагов, формировались различные АТД для 
каждого типа услуг. Например, если нужно было сформировать отчет, который содержал сервисы от группы k, и записать в файл в порядке убывания по прибыли, то я создавал АТД очередь, в которую 
заносились АТД сервисы для АТД группы k (поскольку для каждой группы могли быть свои условия). 

У меня получилось более чем 100 классов по итогу, когда как спецификации подразумевали, что все услуги и методы по рассчетам почти идентичны. Естественно все нюансы выявлялись во время разработки.
Документация с одной страницы разрослась до 15+

# Пример 3

Моменты, когда из "все просто и делается одной функцией" быстро переходил в наличие костылей на первой работе были постоянны.
Например, имелся внутрикорпоративный проект, который я разрабатывал, заключался в предоставлении финансовых показателей партнеров. Первая версия была предельно проста:
обороты, прибыль, выручка и остальные подобные финансы хранились в таблицах, нужно было их пройти в определенном порядке, применить соответствующие формулы и записать результат в таблицу-результат.

Поскольку это был первым моим опытом, я последовал совету "сделать все линейно". Со временем, в проект начали добавлять условия "Для такого сервиса нужно брать доп данные из таблицы ...", "для группы сервисов нет данных в таблице ..., посему нужно брать данные за иной период" и общий алгоритм "пройти в определенном порядке и применить соответствующие формулы" превратился в сложнынй алгоритм с кучей условий, которые было тяжело внедрить. 

Решил я проблему следующим образом. Поскольку партнеры нельзя была рассматривать как "похожие" сущности, я отталкивалсь от различных видов партнеров и способов их рассчета.
Говоря формально, было N партнеров и K способов рассчета. Линейный код порождал проверки NxK, когда как я создавал отдельные АТД для вида партнера и вида рассчета.
То есть был АТД "Партнер А1 с Рассчетом Б1" и был АТД "Партнер А2 с Рассчетом Б2". Функции рассчета была исполнены в функциональном стиле. Код расширялся линейно.

С того момента, к фразе "все просто и делается одной функции" я отношусь со скепсисом.

# Пример 4

Можно ещё вспомнить задачку, которая подразумевала

# Пример 5
