# Долгосрочное проектирование API

Долго думал, в чем суть данного примера и принципа и вот какие мысли у меня появились, которые приведу в первую очередь, а затем примеры.

У нас имеется некоторая реализация сущности (например та же структура). Эта реализация вне зависимости от языка будет тем или иным образом зависеть от окружения, в котором она используется 
(ОС, флаги компиляции, переменные окружения и т.п.). Взаимодействие с этой сущностью может быть:
1) локальным, то есть обращение к API осуществляется в том же окружении, в котором используется обращаемая сущность
2) нелокальным, то есть обращение к API осуществляется необязательно в том же окружении, в котором используется обращаемая сущность.

Подумаем на счет проектирования API в случае локального обращения (речь идет только об экспортируемых функциях и методах). Допустим, мы проектируем API для стэка чисел, и, добавляя операцию
push(integer), мы сталкиваемся со следующей диллемой:
1) push(int item) 
2) push(int* item)
3) push(std::unique_ptr<int>&& item)
4) push(std::shared_ptr<int> item)

Хоть пример и С++, лакомый кусочек тут таков, что возможных вариантов для push намного больше, добавив например const в параметры. Мысль моя такова, что API может менять push на одно из 
вышеприведенных методов, и нам придется менять всех "клиентов" данного API, а это может оказаться сложной задачей.


Теперь поговорим о нелокальном вызове. Помимо различных вариаций API, сложность тут добавляет разница окружений, как например разница между 32 и 64 архитектурами. Можно возразить, мол 
"подобные проблемы ушли", "это слишком низкоуровневые примеры" и "когда последний раз сталкивались с проблемой архитектуры". Идея мне показалосб тут совершенно иной -- мы должны делать API
максимально "нейтральными". То есть, среди множества окружений есть непустое пересечение свойств этих окружений, на которые мы должны обратить внимание. Например, везде int32 работает одинаково
(надеюсь я не ошибаюсь :)


За несколько дней, что я ломал голову над проектирование долгосрочного API, родилась такая идея. Проектируя архитектуру информационной системы мы имеем некоторую область определений для сущности.
И при проектировании API мы должны опираться на пересечении общих свойств среди различных видов сущностей. Например, проектируя электронную библиотеку, у нас есть следующие сущности:

```
Техническая литература (жанр, автор, издательство)

Художественная литература(жанр, издательство, автор, год написания)

Журнал (жанр, издательство, тематика)

```

Храня все эти сущности в едином месте, будь то БД или обычный контейнер, мы должны, как мне кажется, проектировать API для взаимодействия на основе "жанра" и "издательства", то есть пересечении
этих свойств. Что самое важное, мы можем обобщить подобное пересечение до операций! Свормировав "ядро пересечения свойств", мы обеспечиваем обратную совместиость для ранних потребителей API. 


И теперь я перехожу к главное мысли. 

Если наша реализация сущности завязана на конкретной реализации, как в случае с 32-ух разрядной архитектурой, то мы:
1) Либо проектируем API на основе нашей 32-ух разрядной архитектуры и общих свойств "потребителей" нашей API, тем самым обеспечиваем обратную совместимость
2) Если же требуется сделать API, чтобы с ней комфортно работали 64-х разрядные "потребители", то мы делаем новый уровень абстркции для данной API. (Например, разбив int64 на два int 32).

Хороший контраргумент к моим доводам может быть следующим: что если в вышеприведенном примере, где среди "технической литературы", "художественной литературы" и "журнала", у "журнала" 
бизнес потребует убрать свойство "жанр"? Придется ли нам тогда переделывать "ядро пересечений свойств"? Или же нужно отнести теперь "журнал" к иной категории сущностей и для нее проектировать
отдельную иерархию/библиотеку?



Попробую подтвердить свои мысли следующими аргументами-примерами:

# Пример 1



# Пример 2

# Пример 3
