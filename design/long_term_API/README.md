# Долгосрочное проектирование API

Долго думал, в чем суть данного примера и принципа и вот какие мысли у меня появились, которые приведу в первую очередь, а затем примеры.

У нас имеется некоторая реализация сущности (например та же структура). Эта реализация вне зависимости от языка будет тем или иным образом зависеть от окружения, в котором она используется 
(ОС, флаги компиляции, переменные окружения и т.п.). Взаимодействие с этой сущностью может быть:
1) локальным, то есть обращение к API осуществляется в том же окружении, в котором используется обращаемая сущность
2) нелокальным, то есть обращение к API осуществляется необязательно в том же окружении, в котором используется обращаемая сущность.

Подумаем на счет проектирования API в случае локального обращения (речь идет только об экспортируемых функциях и методах). Допустим, мы проектируем API для стэка чисел, и, добавляя операцию
push(integer), мы сталкиваемся со следующей диллемой:
1) push(int item) 
2) push(int* item)
3) push(std::unique_ptr<int>&& item)
4) push(std::shared_ptr<int> item)

Хоть пример и С++, лакомый кусочек тут таков, что возможных вариантов для push намного больше, добавив например const в параметры. Мысль моя такова, что API может менять push на одно из 
вышеприведенных методов, и нам придется менять всех "клиентов" данного API, а это может оказаться сложной задачей.


Теперь поговорим о нелокальном вызове. Помимо различных вариаций API, сложность тут добавляет разница окружений, как например разница между 32 и 64 архитектурами. Можно возразить, мол 
"подобные проблемы ушли", "это слишком низкоуровневые примеры" и "когда последний раз сталкивались с проблемой архитектуры". Идея мне показалосб тут совершенно иной -- мы должны делать API
максимально "нейтральными". То есть, среди множества окружений есть непустое пересечение свойств этих окружений, на которые мы должны обратить внимание. Например, везде int32 работает одинаково
(надеюсь я не ошибаюсь :)


За несколько дней, что я ломал голову над проектирование долгосрочного API, родилась такая идея. Проектируя архитектуру информационной системы мы имеем некоторую область определений для сущности.
И при проектировании API мы должны опираться на пересечении общих свойств среди различных видов сущностей. Например, проектируя электронную библиотеку, у нас есть следующие сущности:

```
Техническая литература (жанр, автор, издательство)

Художественная литература(жанр, издательство, автор, год написания)

Журнал (жанр, издательство, тематика)

```

Храня все эти сущности в едином месте, будь то БД или обычный контейнер, мы должны, как мне кажется, проектировать API для взаимодействия на основе "жанра" и "издательства", то есть пересечении
этих свойств. Что самое важное, мы можем обобщить подобное пересечение до операций! Свормировав "ядро пересечения свойств", мы обеспечиваем обратную совместиость для ранних потребителей API. 


И теперь я перехожу к главное мысли. 

Если наша реализация сущности завязана на конкретной реализации, как в случае с 32-ух разрядной архитектурой, то мы:
1) Либо проектируем API на основе нашей 32-ух разрядной архитектуры и общих свойств "потребителей" нашей API, тем самым обеспечиваем обратную совместимость
2) Если же требуется сделать API, чтобы с ней комфортно работали 64-х разрядные "потребители", то мы делаем новый уровень абстркции для данной API. (Например, разбив int64 на два int 32).

Хороший контраргумент к моим доводам может быть следующим: что если в вышеприведенном примере, где среди "технической литературы", "художественной литературы" и "журнала", у "журнала" 
бизнес потребует убрать свойство "жанр"? Придется ли нам тогда переделывать "ядро пересечений свойств"? Или же нужно отнести теперь "журнал" к иной категории сущностей и для нее проектировать
отдельную иерархию/библиотеку?

Попробую подтвердить свои мысли следующими аргументами-примерами. 

# Довод 1

Затронем вопрос обратной совместимости. 
Для того, что наше API было долгосрочным, мы должна проектировать интерфейс таким образом, чтобы он строился вокруг  "ядра пересечений свойств" конкретного модуля бизнес-логики.
Проектируя электорнную библиотеку, мы выявляем "ядро" для книг. Проектируя автомагазин, мы выявляем "ядро" для продаваемых автомобилей и т.д. Что если в электронную библиотеку бизнес потребует 
внести журналы? Я бы в таком случае рассматривал это отдельно от кнги и применил бы проектирование API для журналов подобно тому, как сделал с книгами. Что если для некоторых книг будет добавлено
новое свойство? Его можно сделать "необязательным", но тогда это лишние проверки на if-ы...лучше сделать это отдельной АТД, как мне кажется с соответствующим APi.   


# Довод 2

Затронем вопрос "окружения".
Использование нейтральных/общих для многих окружений типов данных, будь-то встроенные или комплексные АТД. Тут я следую такой логике: следует работать в одной "плоскоти типов данных" для 
множество окружений. Например, для чисел это int64 -- мы не ломаем 32-ух разрядных клиентов, в случае обращения к нам. 
p.s. вот тут-то я себе и противоречу. В вышеприведенном примерами с книгами, я говорил, что нужно "сузить" набор общих свойств, когда как тут наоборот расширяю его. Но там я руководствуюсь 
больше уменьшением сложности кодовой базы, а в случае с числами руководствуюсь реалиями реализации ОС...



В каких бы случаях я применял данных прием?
1) Рабочий проект на Erlang'e, где модуль транспорта взаимодействует с СМС-центром. Для тестирования, где используется имитация локального СМС-центра или СМС-центра на стейджинге, можно
с помощью макроса определить использумую запись для работы с сообщениями, передаваемые в СМСцентр, будь-то прод, стейдж или локальный. Поскольку мы работаем с одной структурой данных "запись",
мы легко можем настраивать нужную нам работу, что упрощает разработку при разработке.
2) 

