# Что делать с ORM

Для начала, как ослабить ограниченние ORM. Речь будет идти про Laravel, т.к. опыт работы был только с этим фреймворком. Как мне кажется, проблема не столько в ORM, сколько в подходе к выбору инструмента. 
Как только получив первую работу в качестве джуна, я спрашивал "почему именно Laravel", ответ в основном касался "удобной" и "быстрой" разработки. 
Действительно, если писать простые внутрикорпоративные приложения (менее 100к строк кода), то ORM, в котором довольно простые запросы и проект редко расширяется, работает неплохо (хотя зависит от синтаксиса).
Но, когда приходит проект, в которых модели данных неукладываются в парадигму фреймворка....

Например, Laravel прям очень намекает на то, что нужно как можно чаще использовать связи многие-к-одному и как меньше связи многие-ко-многим. 
Стоит посмотреть на документацию по связям между моделями: https://laravel.com/docs/10.x/eloquent-relationships#retrieving-intermediate-table-columns
Связи многие-ко-многим уделено около 10-15% от всей документации. Ко всему этому, для того, чтобы создать связь многие-ко-многим посредством фреймворка, нужно соблюсти множества условий: 
Правильно назвать таблицы сущностей, правильно назвать таблицу-связи, название атрибутов, тип связи и вот подобное не облегчает работу.
И да, ORM в Laravel'e так же требует наличие fk, для уникальности сущности, иначе будет выходить exception.

Касательно того, как ослабить ORM в Laravel -- использовать его тогда, когда он будет удобен, где минимум связей многие-ко-многим. 
Это применимо к нереляционным БД, например MongoDB, вот там ORM заходит на ура, когда не нужно писать JavaScript-запрос, ваши данные находятся локально. 
Да, модели немного усложняются за счет вложенности, но, по крайней мере, у вас не будет указателей на последующие записи (да в Mongo тоже могут быть подобие fk, но они скорее редкость),
вы способны более менее работать с каждой коллекцией сущностей изолированно, т.к. если вы захотите работать с сущностью совместно с сущностью Б (например, водитель с принадлежащими им авто), то это вероятнее всего будет
как отдельная коллекция в Mongo.

В общем я считаю, тут вопрос в подходящем выборе инструментов и подходов к каждой конкретной ситуации, а не "выберем Postgres потому что его все используют".
==============================================================================================================================================================================================================================

Касательно способов улучшения модели данных.
Как мне показывает практика, лучше способ улучшить навык проектирования моделей данных -- изучать, как устроены большие системы: ОС, СУБД и т.п. Там показаны, какие модели используются, почему именно эти модели 
используются и как именно используются. Например, такой своеобразный "паттерн" модели данных -- использовать таблицу сопоставлений (map table). Она используется в виртуальной памяти (сопоставление виртуальный адресов 
и физических), используется в реляционных СУБД, для отражения адресов записей, когда та имеет логический и физический адрес. Или например, вектор обработчиков исключений, который содержит в качестве значения элемента список
подходящий обработчиков, чтобы уменьшить размер вектора, и для каждого обработчика не выделять ячейки, хотя казалось бы...

Также по мере работы с моделями, стоит учитывать их недостатки и способы их разрешения, как например, избыточность информации, свободные объекты и т.д.
Ну и помимоу модели данных, стоит выбрать подходящую парадигму.

В общем, я для себя вижу решение в виде изучения, как делают люди из мира computer science, и пытаться понять, почему именно так они сделали (именно про проектировнаие систем речь, и как организована там модель данных).
