# Триплы Хоара

Доп материал:  https://www.cs.cmu.edu/~aldrich/courses/654-sp07/slides/7-hoare.pdf

# 1
Исходный:
```
{ true };
a = 10;
{ a > 1 }
b = 42;
{ a > 1, b > 1 } 
c = a + b;
{ c > 1 } 
```


Надеюсь, я правильно интерпретировал:
Вариант 1
```
{ true }; # Некоторая входная точка, т.е. мы рассчитывает, что изначально пред-условие истинно и пост-условие будет истинным
a = 10; # Команда 1
{ a > 1 } # Истинное постусловие после команды 1
b = 42; # Команда 2
{ a > 1, b > 1 } # Истинное постусловие после команды 2
c = a + b; # Команда 3
{ c > 1 }  # Истинное постусловие после команды 3
```



### 1 :

Умножение отрицательных чисел на положительные
```
{ true } 

a = -1; # Команда 1
{ a < 0 } # Постусловие 1

b = 1; # Команда 2
{ a < 0, b > 0 } # Постусловие 2

c = a * b; # Команда 3
{ c < 0 } # Постусловие 3
```

### 2 :

Если возведем некоторое слово в степень квадрата,
то примитивное слово будет и суффиксом, и префиксом результат возведения в степень

"aba"^2 = "abaaba"
```
{ true } # Предусловие 1

# Примитивное слово
a = "aba"; # Команда 1
{ a is primitive string} # Постусловие 1

# Степень
b = 2; # Команда 2
{ a is primitive string, b = 2 } # Постусловие 2

c = (a)^2  # Команда 3
{ `a` is prefix `c` ; `a` is suffix `c` } # Постусловие 3
```

### 3 :

Вставка элемент а список
```
{ true } # Предусловие 1

a = empty_linked_list; # Команда 1
{ len(a) == 0 } # Постусловие 1

# creating element
b = 1; # Команда 2
{ b is element } # Постусловие 2

# adding elem to empty list
c = insert(b, a); # Команда 3
{ len(c) == 1 } или {len(c) == len(a) + 1}
```

### 4 :

Логика работы указателей
```
{ true } # Предусловие 1

a = some_var; # Команда 1
{ `a` связана со значением} # Постусловие 1

b = &a; # Команда 2
{ `a` связана со значением, b -- указатель на `a` } # Постусловие 2

c = *b; # Команда 3
{ c == a } # Постусловие 3
```




# 2 

Заполните пустые места правильными условиями:
```
{  }
b = 2 - a;
{  }
c = b * 2;
{  }
d = c + 1;
{d  =  5}
```

Один из вариантов:

```
{ true }
b = 2 - a;
{a = b - 2}
c = b * 2;
{ c = (2-a)*2, b=c/2, c % 2 == 0 }
d = c + 1;
{d  =  5}
```


Решим с Z3 :)

```python
a, b, c, d = Ints('a b c d')

constraints = Solver()
constraints.add(b == 2 -a )
constraints.add(c == b * 2)
constraints.add(d == c + 1)
constraints.add(d == 5)

print(constraints.check()) # решение есть, то имеется такое предусловие, при котором постусловие будет истинно
print(constraints.model())
```

Result:
```
sat
[a = 0, b = 2, d = 5, c = 4]
```

Итого:

Запись немного непривычная, но суть, как я понял такова: если проводить аналогии с Z3, то у нас имеется
1) Набор предоусловий
2) Набор команд

Их можно интерпретировать на z3 тоже как ограничения.
Так вот, если мы создадим солвер с данными ограничениями и, если модель при model.check() == sat, то получается, что у нас имеется такое предусловие, при истинности которого
постусловие гарантированно будет истинным.

```
{ true } #if true -> sat, otherfise false

# constraints
a = 10;
{ a > 1 }
b = 42;
{ a > 1, b > 1 }
c = a + b;
{ c > 1 }
```

Таким образом, можно искать домен предусловий, при которых постусловия будут гарантированно истинными.
