# Краевые случаи

1)

Пример 1

Прохожу курс Go на яндексе и там в качестве исходных дали дали следующую структуру:
```go
type Metrics struct {
    Type string
    GaugeVal float
    CounterVal float
}
```
где Type может быть либо gauge, либо counter. Если Type == gauge, то GaugeVal = значению, а Counter val == nil, и наоборот.

Из-за этого в коде присутствуют всяческие проверки на тип и nil значений:

```go
func (m Metrics) MarshalJSON() ([]byte, error) {
    type MetricStrAlias Metrics    type MetricAlias Metrics
    del := "none"    if m.Delta != nil {
        del = fmt.Sprintf("%d", *m.Delta)    }
    val := "none"
    if m.Value != nil {        val = fmt.Sprintf("%.20f", *m.Value)
    }
    mAlias := struct {        MetricStrAlias
        Delta string `json:"sdelta,omitempty"`        Value string `json:"svalue,omitempty"`
    }{        MetricStrAlias: (MetricStrAlias)(m),
        Delta:          del,        Value:          val,
    }
    alias := struct {        ID    string   `json:"id"`              //Metric name
        MType string   `json:"type"`            // Metric type: gauge or counter        Delta *int64   `json:"delta,omitempty"` //Metric's val if passing counter
        Value *float64 `json:"value,omitempty"` //Metric's val if passing gauge        Hash  string   `json:"hash,omitempty"`  //Metric's val if passing gauge
    }{        ID:    mAlias.ID,
        MType: m.MType,        Hash:  m.Hash,
    }
    delta, err := strconv.ParseInt(mAlias.Delta, 10, 64)
    if err != nil {        alias.Delta = nil
    } else {        alias.Delta = &delta
    }
    Val, err := strconv.ParseFloat(mAlias.Value, 64)    if err != nil {
        alias.Value = nil    } else {
        alias.Value = &Val    }
    return json.Marshal(alias)
}
```

К сожалению. тут только if и спасает, хотя иногда пользуюсь switch'ами и map, чтобы не громоздить if'ы и код был более читаемый.
```go
func MemStoageDB() pidb.MemStorage {
    var imap = map[string]map[string][]byte{}    
    imap["gauge"] = map[string][]byte{}
    imap["counter"] = map[string][]byte{}   
    return pidb.MemStorage{Mutex: sync.RWMutex{}, Metrics: imap}
}

//или

func (d *DefaultHandler) processRetrieve(metric metrics.Metrics) ([]byte, int) {
    switch {    
    case metric.MType == "gauge":
        return d.processRetrieveGauge(metric)    
    case metric.MType == "counter":
        return d.processRetrieveCounter(metric)    
    default:
        return []byte{}, http.StatusNotImplemented    
    }
}
```

По проекту, при получении запроса, повсеместно приходится проверять тип метрики, значение метркии в зависимости от типа, не равен ли nil'у это значение. 
Ситуация осложняется тем, что приходят данные из json'а, и приходится их доставать и валидировать в любом случае.

Пример 2

Одна из самых частых на моей практике обработка краевых случаев связаны с работой контейнерами, когда контейнер хранит, вроде бы одни объекты,, но состояние 
объектов приходится проверять при итерации и разделять их (например, нам нужны json'ы только с определенной схемой).
Внутри циклов  приходится проверять, все краевые условия.

```cpp
std::vector<Json>* files = new std::vector<Json>();
for (auto js : files) {
    if js.containsKey("some") {
        js.removeKey("some")
    }
}
```

Тут хорошее решение из "Чистый код" -- создание классов-оберток над стандартными типами и структурами данных. Причем, если мы хотим хранить только определенные объекты
то в соостветствующий метод добавляем пред-условия.

```cpp
class JsonContainer
{
public:
	const int ADD_STATUS_NIL = -1;
	const int ADD_STATUS_OK = 0;
	const int ADD_STATUS_ERR = 1;

	const int ERASE_STATUS_NIL = -1;
	const int ERASE_STATUS_OK = 0;
	const int ERASE_STATUS_ERR = 1;
	const int ERASE_STATUS_EMPTY = 2;


	JsonContainer();

	//Pre-cond: дан json который соответствует схеме
//Post-cond: json успешно добавлен в контейнер
	void add(Json& file_to_add);

	//Pre-cond: êîíòåéíåð íå ïóñòîé
	//Post_cond: óäàë¸í ïåðâûé ýëåìåíò
	void erase();

	void addAttr(std::string& key, std::string& val);

	//Pre-cond: 
	//Post-cond: âîçâðàùåíî êîëè÷åñòâî ýëåìåíòîâ â êîíòåéíåðå
	size_t size();

	//Pre-cond:
	//Post-cond: âîçâðàùàåò ñòàòóñ êîìàíäû add()
	int get_add_status();

	//Pre-cond: 
	//Post-cond: âîçâðàùàåò ñòàòóñ êîìàíäû erase();
	int get_erase_status();

	//Pre-cond
	//Post-cond
	Json* at(size_t index);

	std::vector<std::string> schema();
	//Pre-cond:
	//Post-cond: î÷èùàåò êîíòåéíåð. 
	~JsonContainer();

private:
	int add_status;
	int erase_status;

	size_t container_size;
	std::vector<Json>* files = nullptr;
};
```

Пример 3

Ещё один пример, связанный с вышеприведенным -- работа с контейнерами, которые имеют фиксированный объем памяти. 
Тут чревато ошибками обращение к освобожденному блоку памяти. Опять же, проблема состоит в том, что код быстро загрязняется этими проверками вне структуры данных.
Это в основном касается массивов.

Тут также хорошее решение -- создать свой класс-обертку над структурой данных с соответствуюищми пред-условиями.
Обычно для работы со структурами данных или типами, я привык создавать классы-обертки, которые заранее определяют корректное поведение.

Пример 4

Ну и ещё есть ситуации, когда нужно распределить объекты по типами, которые вроде бы имеют одну логику, но их реализации лучше разделить.
Доступа к прошлой работе нет, но суть такова, что имеется N сервисов, для которых рассчет прогноза идентичен по общему алгортму (берем данные из оборота, затем 
берем данные из другого показателя, умноженного на коэф и т.д.).
И, вроде бы, тут напрашивается хорошо создать один контейнер для подобных объектов, которые посчитают все за одну итерацию. Проблема в том, что для разных сервисов
были какие-то дополнительные условию, что в свою очередь многократно порождало if'ы и подобное.

Тут решение, которое я бы сделал -- явное отделение реализаций, несмотря на одну логику. Причем основные общепринятые методы расчеты вынести в функциональную часть приложения,
а все краевые случаи -- как отдельные объекты. Тогда, для каждого отдельного случая у нас была бы одна логика потока данных.

=================================================================================================================================================================================

2) Изучив материал, нашел поддержку своего мнения касательно обработки "нестандартных" случаев. Для таких вот случаев, как мне кажется, лучше создавать отдельный 
поток данных. В случае с рецептами, будь-то съедобное, несъедобное, комбинированное и прочее, лучше предопределить для каждых отдельные API и структуры данных.
Вроде бы это увеличит кодовую базу, но логику у нас будет линейная. 
Я приведу минусы скоротечной создании иерархий объектов, интерфейсов и абстракций, которые пораждают проверку всех краевых случаев,
и доводы в пользу сначала программировать для каждого странного случая конкретные блоки кода:
1) Если у нас имеется иерархия I, которая заточена под объекты (i1, i2, ...), то, при каждой новом краевом случае внутри объекта ik, 
мы либо добавляем проверку краевых условий в объект ik, либо расширяем иерархию I (добавляя новый объект в множество объектов i)
2) Согласен с тем, что базовая иерархия, которая была изначально, постепенно размывается и суть всего сложнее уловить
3) Найти иерархию, которая будет ухватывать без проблем все краевые случаи, как мне кажется, невозможно. 
Логика такова: все объектв в Java наследуются от Objects. Все краевые случаи обрабатываться будут в дочерних классов. Смотря на всю иерархию объектов в Java 
(от class Objects до String), мы не сможем ничего сказать об иерархии. Тут скорее вопрос компромиссов, во что отражается данная иерархия, в какой случай обработки данных.

В примере с рецептами, я бы создал для каждого типа блюда отдельную структуру данных и поток управления данных. По мере роста проекта, найдя участки кода, которые точно
будут неизменными (ну хотя бы с 70% вероятностью), я бы вынес их в функциональное ядро, тем самым проведя анти-унификацию. Но были бы разные иерархии:
иерхария с блюдами съедобными, иерархия с блюдами несъедобными, с декоративными и т.д.

Да, тут есть вопрос с граммовками, и прочими условиями, но, как мне кажется, тут вопрос уже грамотной композиции :)
