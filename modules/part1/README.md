# Модули важнее всего

Первое, что пришло на ум при прочтении "реализация удовлетворяет нескольким интерфейсам" -- interface dispatch, которые используется в Golang. 
Пример довольно простой, но очень показательный пример, на который еще буду ссылаться: https://go.dev/play/p/XyasGOmGovh
По реализации мы не можем сказать точно, какой интерфейс реализует структура Foo.

Касательно языков Java/C++ я попытался через дженерики/шаблоны реализовать что-то подобное но вышла откровенно говоря шляпа. Тут больше будет рассуждения на тему модулей и отношению 
"многие-ко-многим" касательно типа и реализации.

Сначала об отношении "многие-ко-многим". Так сложилось, что в моем представлении всегда было такое отношение между реализацией и типом, например:
1) Утка может относиться к типам "птица", "игрушка", "ингридиент".
   а) "Птица" -- которая включает в себя все реализации птиц
   б) "игрушка" -- включает в себя все реализации игрушек
   в) "ингридиент" -- включает в себя все реализации ингридиентов для блюд 
2) Граф может относиться к типам "словарь", "карты города", "сеть друзей".
3) АТД структуры данных, которые содержат insert, delete, seek операции вообще могут удовлетворять многим интерфейсам!

 Обозначим интерфейс insert, delete, seek как InterfaceA, он нам ещё пригодится.

Мне это идея казалось и правильной, с точки зрения логики, и неправильной, с точки зрения, что в мейнстримных ЯП это реализовать просто нельзя (Java, C++), да и казалсоь, что я что-то упускаю.
И, изучив материал по гомоморфизмам, пришла следующая мысль. Если мы вернемся к вышеприведенному примеру на Golang, то можно ли утверждать, что интерфейсы A и B -- гомоморфизмы? Если да, то 
получается, что реализация у нас имеет отношение "многие реализации к одному интерфейсу", но, если вспомнить примеры про отношения "многие-ко-многим", то легко убедимся отношени "многие-к-одному"
в корни неверно. Следовательно, интерфейсы в примере A и B -- не гоморфизмы, а делает их "не гомоморфизмами" свойства методов, которые в языке можно выделить лишь пред и постусловиями. У многих
структур данных имеется единый интерфейс InterfaceA, но за счет свойств, которые "физически" отсутствуют в коде, забываем, что "реализации могут реализовывать множество интерфейсов".

Закрепим небольшой вывод: отношения между интерфейсами и реализациями -- многие-ко многим.

Но что это может нам дать? Чтобы понять преимущества данного утверждения, рассмотрим следующую функцию:

```go
package kernel

func StoreNote(n note.Note, s StorerNote) (note.Note, error) {
   //...
}
```

StoreNote -- записывает n note.Note в хранилище s StorerNote. Если StorerNote обычная реализация, то у нас получается отношение один-к-одному, и гибкость в коде отсутствует.
Сделав StoreNote интерфейсом (не в смысле модуле, а в классическом), то у нас станет отношение 1-ко-многим и наша программа будет устойчивее к изменениям. Но мы смотрим только с перспективы
клиента kernel.StoreNote, и мы опираемся лишь на изменчивость StorerNote! Но если мы "закинем" StoreNote в модуль, закинем kernel в иной модуль, то в таком примере у нас опять получается отношение
"один kernel ко многим StoreNote", которое опять же неверна. Но если мы сможем привести этот пример к схеме "Многим-ко-многим" с правильными модулями, то получится, что мы можем менять как kernel,
так и StorerNote.
Для наглядности примера: представьте, что у вас имеется собранный (на каждой стороне его цвет один) кубик-рубика 2х2. Разделим кубик горизонтально, чтобы он разделился на нижнее две клетки и 
верхние. Нижние две клетки пусть будут kernel и нашего примера, а верхние -- StorerNote. В отношении один-ко-многим, как это реализовано, мы можем "вращать" лишь верхние две клетки, меняя их цвета
(реализацию, удовлетворяющие типу), но нижнюю --не может. И вот при наличие правильных модулей, мы можем вращать как верхнюю, так и нижюю часть кубика-рубика, но при этом они будут 
"взаимодействовать" (в плане, мы все еще может вращать независимо друг от друга верхнюю и нижние части) между собой. И, при такой возможности, у нас будет NxMxKx...P модулей, которые мы можем
"вращать" и получать невероятно гибкую систему.

Но есть нюанс :)
Я все это вижу лишь концептуально, и посмотрев немного на примеры модулей в OCaml, мало что понял. Я реализовывал эту идею вручную на Erlang'e, где для каждого модуля писал "точку входа в него":
например, имеется модуль gen_server, которые экспортируют функции, нежелательные для экспорта (в силу apply и идеологии Erlang'a). Я бы хотел не только изменять свободно сам модуль gen_server,
но и иметь возможность добавлять его в любую точку программы. Для этого писать модуль "взаимодействия" с gen_server'oм, и писать модуль, который принимает данный "gen_server". Выходило правда сложно очень.

Подводя итоги, мне кажется, что время подобной идеи "многие-ко-многим" ещё не наступило (хотя она реализована в OCaml), в силу того, что это довольно сложная тема -- тут и метапрограммирования, 
и теория типов, и пространственная сложность (в плане нужно как-то уместить в мозг думалку по поводу отношения "многие-ко-многим"). Намного проще писать обычный код с паттернами 
(пока я осмысливал весь материал, голова кипела). Да и практика нужна, руки уж чешутся потрогать OCaml и как это там реализовано. 
Вот кстати, тут пришла ещё одна полезная выжимка, которую для себя отметил: если мы смотри на отношение между типами и реализацией, как "один-ко-многим", то это точка "один" будет уязвимым местом
 в нашем проекте.
