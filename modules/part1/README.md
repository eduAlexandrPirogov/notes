# Модули важнее всего

Первое, что пришло на ум при прочтении "реализация удовлетворяет нескольким интерфейсам" -- interface dispatch, которые используется в Golang. 
Пример довольно простой, но очень показательный пример, на который еще буду ссылаться: https://go.dev/play/p/XyasGOmGovh
По реализации мы не можем сказать точно, какой интерфейс реализует структура Foo.

Касательно языков Java/C++ я попытался через дженерики/шаблоны реализовать что-то подобное но вышла откровенно говоря шляпа. Тут больше будет рассуждения на тему модулей и отношению 
"многие-ко-многим" касательно типа и реализации.

Сначала об отношении "многие-ко-многим". Так сложилось, что в моем представлении всегда было такое отношение между реализацией и типом, например:
1) Утка может относиться к типам "птица", "игрушка", "ингридиент".
   а) "Птица" -- которая включает в себя все реализации птиц
   б) "игрушка" -- включает в себя все реализации игрушек
   в) "ингридиент" -- включает в себя все реализации ингридиентов для блюд 
2) Граф может относиться к типам "словарь", "карты города", "сеть друзей".
3) АТД структуры данных, которые содержат insert, delete, seek операции вообще могут удовлетворять многим интерфейсам!

 Обозначим интерфейс insert, delete, seek как InterfaceA, он нам ещё пригодится.

Мне это идея казалось и правильной, с точки зрения логики, и неправильной, с точки зрения, что в мейнстримных ЯП это реализовать просто нельзя (Java, C++), да и казалсоь, что я что-то упускаю.
И, изучив материал по гомоморфизмам, пришла следующая мысль. Если мы вернемся к вышеприведенному примеру на Golang, то можно ли утверждать, что интерфейсы A и B -- гомоморфизмы? Если да, то 
получается, что реализация у нас имеет отношение "многие реализации к одному интерфейсу", но, если вспомнить примеры про отношения "многие-ко-многим", то легко убедимся отношени "многие-к-одному"
в корни неверно. Следовательно, интерфейсы в примере A и B -- не гоморфизмы, а делает их "не гомоморфизмами" свойства методов, которые в языке можно выделить лишь пред и постусловиями. У многих
структур данных имеется единый интерфейс InterfaceA, но за счет свойств, которые "физически" отсутствуют в коде, забываем, что "реализации могут реализовывать множество интерфейсов".

Закрепим небольшой вывод: отношения между интерфейсами и реализациями -- многие-ко многим.

Но что это дает нам? 
