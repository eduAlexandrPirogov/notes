# Логика Хоара для программистов-2 (2)

## Зависимость от более строгого результата, нежели гарантируется спецификацией

### Пример 1

Буквально на днях закрыл свою последнюю задачу на текущий работе, которая хороша показывает ошибку модульного рассуждения.
Дано: имеются сотовые-операторы, которые предоставляют услуги по определенным тарифам. Сами тарифы -- объект, который состоит из 6 таблиц в БД.
Суть задачи заключалась в возможности копирования тарифов, т.е. мы выбираем партнера, выбираем эталонный тариф, выбираем целевых партнеров и копируем целевым партнерам эталонный тариф.

Я реализовал это в виде процедуры:

```sql
create procedure copy_rates_by_template(
    administrator_id INT,
    source_ip varchar(120),
    parent_rate_id INT,
    new_date_item DATE,
    target_partners_array VARCHAR(255) <--- имитация массива через строку: "1,2,..."
)
```

То есть имеется веб-приложение, где пользователь заполняет форму и с выбранными аргументами вызывается процедура в БД.
В чем же я допустил ошибку? Рассмотрим созданною мною спецификацию относительно параметра target_partners_array:
Пред-условие: дан массив целеых партнеров в виде строки вида "1,2,...", для которых будут скопированы тарифы.
Пост-условие: для всех целевых партнеров, в случае отсутствия нарушения ограничений на уровне БД, были созданы тарифы на основе данного parent_rate_id.

Если использовать данную процедуру через веб-приложение, где заранее выдаются корректные данные и происходит их верификация, процедура работает безукоризненно. 
Но что если эту процедуру потребуется вызвать руками из БД? 
При тестировании процедуры, я дал ей несуществующие id целевых партнеров. И, к моему удивлению, процедура отработала без исключений -- в таблице тарифов был создан объект
с полем partner_id, значением которого было несуществующий партнер, что нарушало ссылочную целостность.

То есть пост-условие:  для всех целевых партнеров, (!) в случае отсутствия нарушения ограничений на уровне БД (!)... 
Изучив ситуацию, я выяснил, что на поле partner_id отсутствовало ограничение FK из-за чего нарушалась ссылочная целостность. 
С одной стороны можно сказать, что мое пост-условие не нарушается, т.к не стоит ограничение на уровне БД, но если смотреть на эту ситуацию немного уровнем выше
(не уровень реализации, а логический), то в данной реализации результат работы системы в целом зависит от более жесткого результата, нежели гарантируется моей процедурой 
(зачем нам нужны тарифы, у которых нет владельцев?).

По итогу я добавил дополнительную проверку, тем самым сделав спецификацию пост-условия строже.

### Пример 2

Также пример из текущей работы. Суть задачи заключалась в генерации пароля, который содержал бы спец-символ, верхний и нижний регистр и прочие условия, который в последствии
высылася клиентам. Реализация генерации заключалась в выборе в случайном порядке из алфавита символов:

```php
alphabet = "abcde....ABCD....890" 
```

Я изменил реализацию, чтобы в случайном порядке выбирались байты в пределах ASCII. Сложность заключалась в том, что во время генерации пароля нужно было сделать так, чтобы
каждое требование было удовлетворено при выборе символах из ASCII. 
Добился я этого следующим образом:

```php
 private function generateTillCorrect(int $pass_length) {
        $password = '';
        $attempts = 0;
        while (!preg_match(BSMSPassword::PASSWORD_REGEXP, $password) && $attempts < BSMSPassword::MAX_ATTEMPTS) {
            $password = '';
            $attempts++;
            $password = $this->generatePassword($pass_length);
        }
        return $password;
    }
```

пока не будет удовлетворена регулярка, то пароль будет генерироваться. Вспомнив университетскую мат-статистику, вышло, что генерация и выдача пароля, неудовлетворяющего требованиям
будет менее 0.01%. 

Но! Возможна ситуация, когда пользователь получит неудовлетворяющий требованиям пароль, попробует ввести его при авторизаци, и вместо того, чтобы благополучно авторизоваться, получит
сообщение о том, что "ваш пароль не содержит {что-то}", поскольку верификация пароля будет происходит той же регуляркой, что используется при генерации пароля.
То есть, система зависит от более строгого результата, нежели выдает компонент генерации пароля, несмотря на то, что вероятность данного инцидентна крайне мала.

## Зависимость от возможности использовать более мягкие реализации, чем гарантирует спецификация

### Пример 1

Вернемся к процедуре из примера 1 предыдущего раздела:
```sql
create procedure copy_rates_by_template(
    administrator_id INT,	
    source_ip varchar(120),	<--- имитация массива через строку: "1,2,..."
    parent_rate_id INT,
    new_date_item DATE,
    target_partners_array VARCHAR(255) 
)
```

source_ip - параметр, нужный для логгирования. Мне самому не нравится ее хранить в виде параметра процедуры, но сделано это было, чтобы упростить работу с существующей архиктетурой БД.
Параметр показывает, с какого адреса было сделано действие. Со стороны веб-приложения, где айпи верифицируется и валидируется использование процедуры будет без исключительных ситуаций.

Для использования процедуры "руками", я написал подробную документацию. Для поля source_ip написана следующая строка:
>> Если процедура используется напрямую из БД, то рекомендуется установить значение source_ip = "0.0.0.0", тем самым дав понять, что процедура была вызвана не из веб-приложения.

И валидации source_ip в процедуре не имеется. То есть мы можем передать любую строку в качестве аргумента (имеем более мягкие реализации) и процедура отработает нормально.
Это в свою очередь влияет не просто на поток вычислений, а на консистентное состояние системы в целом! Проблема дополняется еще тем, что проверку, откуда была вызвана процедура
(из-веб приложения или из БД руками) очень муторно.

Что тут можно сделать? Например, дать права на использование данной процедуры только веб-приложением, а для работы с данной процедурой из БД создать процедуру-API, 
которая в свою очередь будет вызывать нашу процедуру, а доступ к процедурам ограничить в БД на уровне прав.

### Пример 2

Еще один пример, где при ином варианте входных данных. В данном функции суть заключается в маскировании номера абонента, кроме последних 4-ех цифр.
То есть дается номер 79998887766 и выдается XXXXXXX7766
```php
 function mask($abonent) {
        $str = "XXXXXXXXXXXXXXX" . preg_replace("~^.*([0-9]{4})$~", "\\1", $abonent);
        return substr($str, -strlen($abonent));
    };
```

Но однажды к этой функции пришел следующий формат номера: +7-999-888-77-66 из-за чего функция его не замаскировала.
То есть при ином варианте входных данных( пред-условие содержит строку "передан номер абонента" без формата), несмотря на вроде-бы корректные входные данные, 
функция отрабатывает не так, как желается.

## Принцип робастности/надёжности Постела

При написании программных компонентов, я стараюсь избегать данного принципа и максимально строко и четко обозначать границы/политику использования интерфейса моих компонентов.
Во-первых, если мы будем стараться "позволять клиентам выходить за рамки протокола до тех пор, пока мы их понимаем", то нам потребуется добавить логику для обработки бОльших вариантов
входящих данных.
Во-вторых, в системе образуется "жирная точка", к которой обращаются все, кому не лень, что мне кажется не лучшим вариантом.
В-третьих, это прямое нарушение SRP. Программный компонент имеет четко-определенный интерфейс и не должен заниматься "подгонкой" входных данных под интерфейс. 


## Общение с коллегами на уровне спецификаций.

Единственный коллега, который принял мою идею общения и реалазции требований на уровне спецификаций был ПМ-ом. С ним было просто составлять требования и претворять их в жизнь.
С коллегами-разработчиками ситуация сложнее. Это часто выливается в дискуссии и "сделаю как считаю нужным". Я никого не обвиняю и не хочу сказать, что они делают неправильно, но 
вот статистика такова, что с ПМ-ом получилось наладить общение на таком уровне, а вот с коллегами -- не особо. 

## По итогу

При реализация требований клиента или добавления новой функциональности для меня предстает в виде моделирования потока вычислений, его декомпозиции и последующего соединениия 
декомпозированных частей воедино. Соединение частей заключается в формировании протоколов и политик, которые говорят об использовании компонентов. Компонент должен начинать свою
работу если и только если удовлетворены пред-условия, и выдает корректный результат, удовлетворяющий пост-условию если и только если на вход подается четко-определенный домен.
Не должно быть такого, чтобы при неправильный пред-условиях компонент отрабатывать штатно.

Соединение декомпозированных компонентов таким образом, чтобы система была робастной есть моя задача. Это мышление можно применять не только в рамках конкретного языка программирования
но и в целых архитектурах: компнент К1 принимает на вход данные, обрабатывает их и передает компоненту К2, соблюдая четко определенные политики. Данные политики и есть третий 
логический уровень мышления на разрабтываемой системой.
