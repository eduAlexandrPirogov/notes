# Логика Хоара для программистов-2 (2)

## Зависимость от более строгого результата, нежели гарантируется спецификацией

### Пример 1

Буквально на днях закрыл свою последнюю задачу на текущий работе, которая хороша показывает ошибку модульного рассуждения.
Дано: имеются сотовые-операторы, которые предоставляют услуги по определенным тарифам. Сами тарифы -- объект, который состоит из 6 таблиц в БД.
Суть задачи заключалась в возможности копирования тарифов, т.е. мы выбираем партнера, выбираем эталонный тариф, выбираем целевых партнеров и копируем целевым партнерам эталонный тариф.

Я реализовал это в виде процедуры:

```sql
create procedure copy_rates_by_template(
    administrator_id INT,
    source_ip varchar(120),
    parent_rate_id INT,
    new_date_item DATE,
    target_partners_array VARCHAR(255) <--- имитация массива через строку: "1,2,..."
)
```

То есть имеется веб-приложение, где пользователь заполняет форму и с выбранными аргументами вызывается процедура в БД.
В чем же я допустил ошибку? Рассмотрим созданною мною спецификацию относительно параметра target_partners_array:
Пред-условие: дан массив целеых партнеров в виде строки вида "1,2,...", для которых будут скопированы тарифы.
Пост-условие: для всех целевых партнеров, в случае отсутствия нарушения ограничений на уровне БД, были созданы тарифы на основе данного parent_rate_id.

Если использовать данную процедуру через веб-приложение, где заранее выдаются корректные данные и происходит их верификация, процедура работает безукоризненно. 
Но что если эту процедуру потребуется вызвать руками из БД? 
При тестировании процедуры, я дал ей несуществующие id целевых партнеров. И, к моему удивлению, процедура отработала без исключений -- в таблице тарифов был создан объект
с полем partner_id, значением которого было несуществующий партнер, что нарушало ссылочную целостность.

То есть пост-условие:  для всех целевых партнеров, (!) в случае отсутствия нарушения ограничений на уровне БД (!)... 
Изучив ситуацию, я выяснил, что на поле partner_id отсутствовало ограничение FK из-за чего нарушалась ссылочная целостность. 
С одной стороны можно сказать, что мое пост-условие не нарушается, т.к не стоит ограничение на уровне БД, но если смотреть на эту ситуацию немного уровнем выше
(не уровень реализации, а логический), то в данной реализации результат работы системы в целом зависит от более жесткого результата, нежели гарантируется моей процедурой 
(зачем нам нужны тарифы, у которых нет владельцев?).

По итогу я добавил дополнительную проверку, тем самым сделав спецификацию пост-условия строже.

### Пример 2



## Зависимость от возможности использовать более мягкие реализации, чем гарантирует спецификация

### Пример 1

Вернемся к процедуре из примера 1 предыдущего раздела:
```sql
create procedure copy_rates_by_template(
    administrator_id INT,	
    source_ip varchar(120),	<--- имитация массива через строку: "1,2,..."
    parent_rate_id INT,
    new_date_item DATE,
    target_partners_array VARCHAR(255) 
)
```

source_ip - параметр, нужный для логгирования. Мне самому не нравится ее хранить в виде параметра процедуры, но сделано это было, чтобы упростить работу с существующей архиктетурой БД.
Параметр показывает, с какого адреса было сделано действие. Со стороны веб-приложения, где айпи верифицируется и валидируется использование процедуры будет без исключительных ситуаций.

Для использования процедуры "руками", я написал подробную документацию. Для поля source_ip написана следующая строка:
>> Если процедура используется напрямую из БД, то рекомендуется установить значение source_ip = "0.0.0.0", тем самым дав понять, что процедура была вызвана не из веб-приложения.

И валидации source_ip в процедуре не имеется. То есть мы можем передать любую строку в качестве аргумента (имеем более мягкие реализации) и процедура отработает нормально.
Это в свою очередь влияет не просто на поток вычислений, а на консистентное состояние системы в целом! Проблема дополняется еще тем, что проверку, откуда была вызвана процедура
(из-веб приложения или из БД руками) очень муторно.

Что тут можно сделать? Например, дать права на использование данной процедуры только веб-приложением, а для работы с данной процедурой из БД создать процедуру-API, 
которая в свою очередь будет вызывать нашу процедуру, а доступ к процедурам ограничить в БД на уровне прав.

### Пример 2


## Принцип робастности/надёжности Постела

При написании программных компонентов, я стараюсь избегать данного принципа и максимально строко и четко обозначать границы/политику использования интерфейса моих компонентов.
Во-первых, если мы будем стараться "позволять клиентам выходить за рамки протокола до тех пор, пока мы их понимаем", то нам потребуется добавить логику для обработки бОльших вариантов
входящих данных.
Во-вторых, в системе образуется "жирная точка", к которой обращаются все, кому не лень, что мне кажется не лучшим вариантом.
В-третьих, это прямое нарушение SRP. Программный компонент имеет четко-определенный интерфейс и не должен заниматься "подгонкой" входных данных под интерфейс. 

## Общение с коллегами на уровне спецификаций.

Единственный коллега, который принял мою идею общения и реалазции требований на уровне спецификаций был ПМ-ом. С ним было просто составлять требования и претворять их в жизнь.
С коллегами-разработчиками ситуация сложнее. Это часто выливается в дискуссии и "сделаю как считаю нужным". Я никого не обвиняю и не хочу сказать, что они делают неправильно, но 
вот статистика такова, что с ПМ-ом получилось наладить общение на таком уровне, а вот с коллегами -- не особо. 
