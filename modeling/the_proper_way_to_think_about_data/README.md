# Как правильно думать над моделью данных

Внутрикорпоративный проект на прошлой работе, суть которого заключалось в следующем: нужно было вести финансовый учет для сервисов-партнеров.
Сервисы-партнеры относились к различным группам (1к1). У каждого сервис-партнера был договор, а к договору могли идти доп. соглашения (а к доп соглашениям другие договора, то есть такое дерево формировалось).
Также сервис-партнеры имели дату, пока они активны и формулы, для рассчета финансовых показателей. Теперь к примерам.

# Пример 1

Была такая зона API, которая отвечала за информативность договоров сервисов-партнеров -- выдавала пользователю json с массивом по информации для сервисов, включающий:
1) договора
2) все доп соглашения договоров
3) дата юридической действительности договора

Изначально, чтение всех договоров было сделано в виде SQL-процедур, но при изменений требований, изменять эти процедуры стало трудозатратно.
Во-первых, были self-referenced таблица договоров, что влияло на производительность.
Во-вторых, изменение требование требовало внесение изменение в схеме отношения.

Далее, пришлось делать собственную структуру данных дерево-договоров, где узел был парой (договор, сервис). Формировалось дерево по запросу.
Но стало проблемным редактирование дерева и его последующее сохранение в БД (если проходили инварианты у дерева, то могли не пройти у БД, и наоборот).
Стоит сказать ещё, что ситуацию осложнял Laravel с моделями, когда они были ни к чему, и нужно было писать самому запросы к БД.

Проблема:
Дерево договоров хорошо отражало их природу в код, но в связи с инвариантами, редактирование дерева было проблемным.

По порядку, нужно выявить инварианты относительно сервис-договор-[доп соглашения], и исключить нелегальные состояния. 
1) У сервисы-партнера может быть один действующий договор на определенный момент времени.
2) У действующего договора могли быть доп соглашения, которые относились только нему.
3) Если действующий договор становился недействительным, то его доп соглашения также становились недействительными
4) Если нужно было заменить действующий договор, то требовалось добавить новый договор в систему, закрыть текущий и assign новый договор сервису. (вот самый проблемный момент)

Для переназначение договора (по факту редактирование узла дерева с учетом инвариантов) -- приходилось удалять узел, т.к. в связи с первым инвариантом
у сервиса нельзя удалить договор, и формировать узел, который включал в себя поиск, валидацию назначения договора и подобные вещи.

Как бы сделал я:

Мне корнем всех проблем казался список инвариантов, которые в некоторых ситуациях был противоречивым.
Но если использовать избыточность информации, то, возможно, попробовал бы этот способ:

Я бы сделал кэш дерева договоров, которые ослабивал бы некоторые инварианты. Назовем его edit_contracts_tree.
Редактирование осуществлялось бы через него, т.е. оно создавалось бы на основе исходного edit_tree. 
Теперь, вопрос назначение нового договора сервису. 
Обсудим простую видимую мне схему: мы заменяем договор удачно в соотвествтующем узле в edit_contracts_tree и делаем его текущем contract_tree, а прошлое удаляем.
Как мы поймем, что договор удачно заменен? Тут включается множество факторов, касательно, бизнес-требований, но реализовать это можно с помощью пайпов.
То есть схема такая
1) Имеется исходное дерево контрактов contract_tree
2) При запросе на замену договора, создается реплика contract_tree -- edit_contracts_tree и к нему применяется редактирование
3) Пользователь нажимает "применить изменения" и edit_contracts_tree проходит через пайпы валидации, и при фейле пайпа, пользователю высвечивается ошибка
4) При удачном изменения, edit_contracts_tree становится contracts_tree

Получается, что edit_contracts_tree почти полностью повторяет contracts_tree, за исключением более слабого инварианта, а также доп логики валидации через пайпы.

Вопрос еще в том, упростит ли это пользователям класса contracts_tree? 
Вот я бы сделал это в декларативной модели следующим образом:

replace_contract(contract, tree) -> edit_contracts_tree // заменяет в дереве договоров договор и возвращает экземпляр edit_contracts_tree
validate_edit(edit_contracts_tree) -> error // валидирует дерево и в случае ошибки возвращает error, иначе пустую ошибку?
replace_tree(edit_contracts_tree) -> contracts_tree // заменяет дерево.

Из плюсов такого подхода, как мне видится -- простота валидации, отсутствие изменяемых значений
Из минусов -- бьет по памяти дорого (относительно, чего правда, сложно сейчас сказать), каждый раз создавать дерево (доп соглашений может быть множество), но это можно решить своеобразным партицированием.
Но и такой подход не подошел бы в той команде :)


# Пример 2

Также пример с прошлой работы. Суть иного внутрикорпоративного проекта заключался в экстраполяции финансовых показателей сервисов-партнеров.
Сервисы-партнеры относились к группам по типу экстраполяции. 
Экстраполяции финансовых показателей нужно было проводить по:
1) каждому сервису за определнный период (за неделю, месяц, квартал, год)
2) каждой группе сервисов
3) каждому из двух вышеперечисленных пунктов по определенному типу экстраполяции

Группы и сервисы-партнеры отражались в модели Laravel.
Для рассчета финансовых показателей, был класс-контейнер, ключом которого выступала группа а значением -- список сервисов.
То есть для группы, производить рассчеты было просто и быстро, относительно того, что рассчеты для сервисов (а были условия, что нужно выбрать некоторые сервисы из различных груп) были намного сложнее.

В общем, тут я бы также применил способ информационной избыточности, и создал бы класс, содержащий две мапы:

map[service_group]->list(services) // легко производим рассчеты по группам
map[service_name]->service // легко производим рассчеты по сервисам (при учете, что имена сервисов-партенров уникальны)

Кстати, для первого случая, соблюдать инвариант уникальности имен сложнее, нежели для второго случая.
Синхронизация осуществлялась бы следующим образом, например, при добавление сервиса для рассчета:

```
Добавить сервис в map[service_name]. Если существует, то выбросить ошибку
Иначе
По указателю service на service_group, определить, что группа существует. Если не существует -- создать
Иначе
выбросить ошибку (мы не можем заменить текущую группу)
```

# Пример 3

Опять же, относительно финансов. Пример больше про храннение в БД, но тоже присутствует принцип избыточности информации (если его можно назвать принципом).
Была такая функция на PL/SQL, суть которой было месячное прогнозирование (отличается от второго примера тем, что данные в таблицах, откуда брались исходные данные, поступали от партнера + от партнера поступали их рассчеты, а во втором примере все данные имелись у компании).

Проблема заключалась в расхождении на 10%-15% у некоторых сервисов. Опять же, сервисы могли относиться к некоим группам, у каких-то сервисов были различные условия рассчета (с учетом скидки, с учетом трафика т.п.).
И функцию для рассчета долго подгоняли под цифры, и она часто менялась. (причем расхождения находились далеко не сразу)
Результат функции заносился в отдельную таблицу forecast_services

Как решили эту проблему. Создали одну большую таблицу detailed_forecast_services, которая включала столбцы всех условий [with_discount, without_discount, traffic1, traffick, with_linear_ex....].
Функция изначально заполняла эту таблицу. Затем, прежде чем заполнять итоговую таблицу forecast_services, она сравнивала полученные значения с теми, которые присылал партнер, и, если
все совпадало, то попадало в итоговую таблицу, иначе, приходил аллерт.

Функцию можно было спокойно использовать и понимать, почему некоторые рассчеты расходились, хотя пришлось для этого создать еще другие функции.

Вывод:

Подобную информационную избыточность я изначально воспринимал как антипаттерн, но вот сейчас появилсь веские доводы подумать о ней. 
Тут в первую очередь вопрос о том, какая структура используется для данных, какие операции выполняются над этой структурой (плюсы и минусы грубо говоря).
С помощью вот подобной информационной избыточности, можно сгладить некоторые минусы АТД (имеется ввиду, что мы создаем обертку над контейнером), но логика, конечно усложниться.
Но зато, не нужно будет создавать методов по типу func AsMap() map[string]int, над которой пользователь и будет совершать действия.

Это, скорее, как дополнительный взгляд на моделирование данных, и вот с мапой тут пример очень показателен:
а) мы хотим, чтобы мапа в качестве ключа хранила А, а в качестве значения -- Б
б) мы хотим, чтобы мапа в качестве ключа хранила Б, а в качестве значения -- А
в) мы хотим, оба вышеперечисленных варианта

И вот рассматривая эти варианты, можно прийти к лучшему решению (или же избежаьть худшего). Ну и работает это не только относительно мап. 
Например, хотим ли мы хранить в узлах дерева список, или в списке -- корень дерева.

В общем, для меня, это ещё один нюанс, который стоит учитывать и рассматривать, при system design'е. 
