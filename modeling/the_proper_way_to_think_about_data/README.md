# Как правильно думать над моделью данных

Внутрикорпоративный проект на прошлой работе, суть которого заключалось в следующем: нужно было вести финансовый учет для сервисов-партнеров.
Сервисы-партнеры относились к различным группам (1к1). У каждого сервис-партнера был договор, а к договору могли идти доп. соглашения (а к доп соглашениям другие договора, то есть такое дерево формировалось).
Также сервис-партнеры имели дату, пока они активны и формулы, для рассчета финансовых показателей. Теперь к примерам.

# Пример 1

Была такая зона API, которая отвечала за информативность договоров сервисов-партнеров -- выдавала пользователю json с массивом по информации для сервисов, включающий:
1) договора
2) все доп соглашения договоров
3) дата юридической действительности договора

Изначально, чтение всех договоров было сделано в виде SQL-процедур, но при изменений требований, изменять эти процедуры стало трудозатратно.
Во-первых, были self-referenced таблица договоров, что влияло на производительность.
Во-вторых, изменение требование требовало внесение изменение в схеме отношения.

Далее, пришлось делать собственную структуру данных дерево-договоров, где узел был парой (договор, сервис). Формировалось дерево по запросу.
Но стало проблемным редактирование дерева и его последующее сохранение в БД (если проходили инварианты у дерева, то могли не пройти у БД, и наоборот).
Стоит сказать ещё, что ситуацию осложнял Laravel с моделями, когда они были ни к чему, и нужно было писать самому запросы к БД.

Проблема:
Дерево договоров хорошо отражало их природу в код, но в связи с инвариантами, редактирование дерева было проблемным.

По порядку, нужно выявить инварианты относительно сервис-договор-[доп соглашения], и исключить нелегальные состояния. 
1) У сервисы-партнера может быть один действующий договор на определенный момент времени.
2) У действующего договора могли быть доп соглашения, которые относились только нему.
3) Если действующий договор становился недействительным, то его доп соглашения также становились недействительными
4) Если нужно было заменить действующий договор, то требовалось добавить новый договор в систему, закрыть текущий и assign новый договор сервису. (вот самый проблемный момент)

Для переназначение договора (по факту редактирование узла дерева с учетом инвариантов) -- приходилось удалять узел, т.к. в связи с первым инвариантом
у сервиса нельзя удалить договор, и формировать узел, который включал в себя поиск, валидацию назначения договора и подобные вещи.

Как бы сделал я:

Мне корнем всех проблем казался список инвариантов, которые в некоторых ситуациях был противоречивым.
Но если использовать избыточность информации, то, возможно, попробовал бы этот способ:

Я бы сделал кэш дерева договоров, которые ослабивал бы некоторые инварианты. Назовем его edit_contracts_tree.
Редактирование осуществлялось бы через него, т.е. оно создавалось бы на основе исходного edit_tree. 
Теперь, вопрос назначение нового договора сервису. 
Обсудим простую видимую мне схему: мы заменяем договор удачно в соотвествтующем узле в edit_contracts_tree и делаем его текущем contract_tree, а прошлое удаляем.
Как мы поймем, что договор удачно заменен? Тут включается множество факторов, касательно, бизнес-требований, но реализовать это можно с помощью пайпов.
То есть схема такая
1) Имеется исходное дерево контрактов contract_tree
2) При запросе на замену договора, создается реплика contract_tree -- edit_contracts_tree и к нему применяется редактирование
3) Пользователь нажимает "применить изменения" и edit_contracts_tree проходит через пайпы валидации, и при фейле пайпа, пользователю высвечивается ошибка
4) При удачном изменения, edit_contracts_tree становится contracts_tree

Получается, что edit_contracts_tree почти полностью повторяет contracts_tree, за исключением более слабого инварианта, а также доп логики валидации через пайпы.

Вопрос еще в том, упростит ли это пользователям класса contracts_tree? 
Вот я бы сделал это в декларативной модели следующим образом:

replace_contract(contract, tree) -> edit_contracts_tree // заменяет в дереве договоров договор и возвращает экземпляр edit_contracts_tree
validate_edit(edit_contracts_tree) -> error // валидирует дерево и в случае ошибки возвращает error, иначе пустую ошибку?
replace_tree(edit_contracts_tree) contracts_tree // заменяет дерево.

Из плюсов такого подхода, как мне видится -- простота валидации, отсутствие изменяемых значений
Из минусов -- бьет по памяти дорого, каждый раз создавать дерево (доп соглашений может быть множество), но это можно решить своеобразным партицированием.
Но и такой подход не подошел бы в той команде :)



# Пример 2

свой проект

# Пример 3

мс
