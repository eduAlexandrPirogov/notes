# Когда наследование лучше композиции?

Статья: Reframing the Liskov Substitution Principle through the Lens of Testing

2. Идея того, что тесты для супертипа должны проходить также для suptyp'а очень интересна, и, изучив статью "Reframing the Liskov Substitution Principle through
the Lens of Testing" понял, почему это хорошо и просто работает. Думал об этом раньше, но, из-за того, что я терялся в понятии между "более сильным" и "более слабым" пред и пост условий, когда
речь не шла об диапазонах, как-то забил на возможность замены в тестах экземпляр родительского класса (оказывается, я нарушал LSP). Помимо тестов, можно использовать assert'ы для
предусловий suptype, взятые из supertype предусловий supertype, как было приведено в статье.

3. Если брать в учет, что наследование стоит использовать лишь тогда, когда полезно использовать полиморфизм подтипов, то ситуация выглядит следующей: 

Пример 1.



Пример 2.



Пример 3.
Это был первый раз, когда я писал внутрикорпоративный проект сам, и тогда же прошел курс по АТД, часть 2, где воодушевился использованием
наследования. Этот проект для экстраполяции финансовых показателей, который уже не раз приводил в отчетах, но тут будет его самая первая версия.
Первоначально спецификация звучала так: нужно для сервисов рассчитать с помощью данных формул/алгоритмов экстраполяцию данных. 
На основе ТЗ, мой проект содержал классы, отражающие способы вычисления:

```php
class ForecastDefault {

    public function Turnover() {

    }

    public function CostPrice() {

    }

    public function Profit() {

    }
}

class ForecastByDate extends ForecastDefault {
    public function CorrelateByDate(Interval $interval) {

    }
}

class ForecastWithCorrelation extends ForecastDefault {
     public function CorrelateWith(Correlation $corr) {

     }
}
```

Свой подход я объяснял так, мол, наследование тут хорошо, поскольку алгоритм экстраполяции имеется общий у них (используя методы Turnover(), CostPrice(), Profit()), 
но для некоторых сервисов нужны дополнительные действия, и повторное использование кода тут подходит в самый раз. В случае чего, я всегда мог переопределить наследуемый метод, 
если требовались изменения.

Рассмотрим данный случай с точки зрения полиморфизм подтипов. Хоть в том проекте мне это и не понадобилось, но порассуждать на эту тему стоит. Допустим, мне нужно было бы для определенного
сервиса все способы экстраполяции, чтобы, например, узнать, какой из способ дает наименьшее расхождение с согласованными данными. Функция может иметь вид:

```php
class Comparator {
    //Return 1 if $first is better than the $second one, otherwise -1
    public function Compare(Service $service, ForecastDefault $first, ForecastDefault $second){
    }
}
```

Рассмотрим случай с точки зрения полиморфизма подтипов. Для сервиса S я мог применить любой подход из переданных наследуемых методов, будь то родительский ForecastDefault, или же
любой дочерний. Важно отметить, что я "угадал" на тот момент с полиморфизмом подтипов, поскольку не знал про тестирование для дочерних классов через родительские тесты. 
Смотря сейчас на этот проект, учитывая данные на тот момент пред и постусловия (их либо не было вовсе, либо они были элементарные), то я никак не нарушил правило сужения/расширения 
пост и предусловий соответственно. 
1) Получается такая картина, что мог передать любой класс из иерархии в метод Compare(...), поскольку сохраняю равноправность (о равноправности я пишу ниже).
2) Я использовал лучшие стороны наследования: повторное использование кода, и полиморфизм подтипов.
