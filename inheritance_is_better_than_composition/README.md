# Когда наследование лучше композиции?

Статья: Reframing the Liskov Substitution Principle through the Lens of Testing

2. Идея того, что тесты для супертипа должны проходить также для suptyp'а очень интересна, и, изучив статью "Reframing the Liskov Substitution Principle through
the Lens of Testing" понял, почему это хорошо и просто работает. Думал об этом раньше, но, из-за того, что я терялся в понятии между "более сильным" и "более слабым" пред и пост условий, когда
речь не шла об диапазонах, как-то забил на возможность замены в тестах экземпляр родительского класса (оказывается, я нарушал LSP). Помимо тестов, можно использовать assert'ы для
предусловий suptype, взятые из supertype предусловий supertype, как было приведено в статье.

3. Если брать в учет, что наследование стоит использовать лишь тогда, когда полезно использовать полиморфизм подтипов, то ситуация выглядит следующей: 

Пример 1.
На одной из работ частенько присылали файлы, которые парсились и возникла идея написать библиотеку "базовый парсер" от которого наследовались дочерние парсеры для каждой из ситуаций.
Основной довод был в том, что бОльшие части кода могли повторяться (как, например, конфигурации парсера, способ итерации, сепараторы). В итоге родилась такая иерархия:

```php
//Отдельный внутрикорпоративный репозиторий с либой
class CompanyNameBaseParser{
    protected $config;
    protected $iterator;
    
    public function Iterate() {
         //...
    }
}
``` 

Остальные парсеры для каждого из проекты выглядели так:
```php
class ServicesReportFromT1 extends CompanyNameBaseParser {

}

class QuartalProfits extends CompaneNameBaseParser {

}

```

Наследование помогало здесь в определенной ситуации, мол для каждого случая писать конфиги, итераторы, из тысячи строк которых 80% буду похожими не хотелось бы, а 
если нужно иное поведение, то достаточно переопределить метод. Но тут есть проблемы:
1) Сам  CompanyNameBaseParser в своем экземпляры нигде не использовался, он просто "висит" в кодовой базе.
2) От конфигурации CompanyNameBaseParser зависят дочерние  парсеры, и, в случае изменения конфига, придется "перелопатить" дочерние парсеры. Это, кстати и произошло, из-за чего запрещалось
изменять базовый парсер, т.к. другие могли сломаться и из-за этого приходилось писать свои с нуля.

Обсудив минусы, что тут можно сделать. В целом, я бы разделил для каждого парсера отдельную репу, потому что"несмотря на то, что логика парсеров во многом схожа, реализация у них должна быть у каждого своя. Я попытался несколько раз придумать, как лучше организовать иерархию между парсерами, чтобы использовать преимущества повторного кода, но вот как-то выходили все время криво.
Об использовании наследования написал свои мысли в самом "Итого". 

Пример 2.



Пример 3.
Удачное применение наследования. Это был первый раз, когда я писал внутрикорпоративный проект сам, и тогда же прошел курс по АТД, часть 2, где воодушевился использованием
наследования. Этот проект для экстраполяции финансовых показателей, который уже не раз приводил в отчетах, но тут будет его самая первая версия.
Первоначально спецификация звучала так: нужно для сервисов рассчитать с помощью данных формул/алгоритмов экстраполяцию данных. 
На основе ТЗ, мой проект содержал классы, отражающие способы вычисления:

```php
class ForecastDefault {

    public function Turnover() {

    }

    public function CostPrice() {

    }

    public function Profit() {

    }
}

class ForecastByDate extends ForecastDefault {
    public function CorrelateByDate(Interval $interval) {

    }
}

class ForecastWithCorrelation extends ForecastDefault {
     public function CorrelateWith(Correlation $corr) {

     }
}
```

Свой подход я объяснял так, мол, наследование тут хорошо, поскольку алгоритм экстраполяции имеется общий у них (используя методы Turnover(), CostPrice(), Profit()), 
но для некоторых сервисов нужны дополнительные действия, и повторное использование кода тут подходит в самый раз. В случае чего, я всегда мог переопределить наследуемый метод, 
если требовались изменения.

Рассмотрим данный случай с точки зрения полиморфизм подтипов. Хоть в том проекте мне это и не понадобилось, но порассуждать на эту тему стоит. Допустим, мне нужно было бы для определенного
сервиса все способы экстраполяции, чтобы, например, узнать, какой из способ дает наименьшее расхождение с согласованными данными. Функция может иметь вид:

```php
class Comparator {
    //Return 1 if $first is better than the $second one, otherwise -1
    public function Compare(Service $service, ForecastDefault $first, ForecastDefault $second){
    }
}
```

Рассмотрим случай с точки зрения полиморфизма подтипов. Для сервиса S я мог применить любой подход из переданных наследуемых методов, будь то родительский ForecastDefault, или же
любой дочерний. Важно отметить, что я "угадал" на тот момент с полиморфизмом подтипов, поскольку не знал про тестирование для дочерних классов через родительские тесты. 
Смотря сейчас на этот проект, учитывая данные на тот момент пред и постусловия (их либо не было вовсе, либо они были элементарные), то я никак не нарушил правило сужения/расширения 
пост и предусловий соответственно. 
1) Получается такая картина, что мог передать любой класс из иерархии в метод Compare(...), поскольку сохраняю равноправность (о равноправности я пишу ниже).
2) Я использовал лучшие стороны наследования: повторное использование кода, и полиморфизм подтипов.
