# Компромисс между удобством и возможностями

+---------+
|#Пример 1|
+---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|    Переписал один из проектов из ООП в функциональной парадигме. Проект заключалсяя в рассчете финансов, и ФП идеально подходило, как мне показалсоь для этой задачи.      |
| Проект переписывался на PHP, и в виду того, что он поддерживал функции, как объекта первого порядка, итоговая кодовая база скоратилась раза в 3.                           |
| Хоть и требовалось соблюдать самому свойства, свойственный ФП (иммутабельные структуры данных, чистые функции), но созданные по итогу чистые функции привело к тому, что   |
| стало легко тестировать проект, часть функций многократно переиспользовалась, поддерживать и вносить фичи в проект стало проще.                                            |
| То есть, это стало менее удобно (соблюдать свойства ФП), но количество багов в проде было минимизировано и добавило простоту поддержки проекта.                            |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


+--------+
|#Пример2|
+---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|    Предложил добавить СУБД Mongo для небольшого сервиса небольшой компании. Их деятельность была связана с ботом телеграмма, который отслеживал товары из разных магазинов,|
| и присылал предложения пользователю. Изначально хотели сделать в на Postgres'e, но в виду того, что для проектированиях схемы БД оказалось сложным и породило только для   |
| для прототипа сотню таблиц и для одного запросы приходилось обходить десятки таблиц, плюс запросы были с многочисленными подзапросами.                                     |
|    Mongo была предложена под тем предлогом, что это позволит упростить запросы на чтение данных (чтение происходило намного чаще, нежели запись). Также, это ускорит       |
| разработку прототипа, за счет того, что отражать реляционную модель в ООП код сложнее, нежели отражать JSON в JSON.                                                        | 
| Через какое-то время, я узнал, как идут дела с Mongo, и сказали, что хоть и запросы стали проще проще, но как только со временем, структура документов так сильно менялась,|
| что приходилось создавать новые коллекции все чаще, но это заняло меньше времени.                                                                                          |
| P.S По итогу все равно перешли на Postgres, после использоавния прототипа.                                                                                                 |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+---------+
|#Пример 3|
+---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|    Использование инструмента для миграций. В основном все проекты разворачивались с помощью встроенных в Laravel миграций. Это, хоть простой инструмент, но по мере        |
| появления задач, по добавлению, редактированию и удалению строк, папка миграций начала состоять из десятков миграций, которые тяжело было отслеживать.                     |
|    В качестве эксперимента, предложил использовать Liquibase -- инструмент для миграций, который широко используется среди Java разработчиков. Вместо того, чтобы на       |
| каждую небольшую задачу по изменнению пары строк в БД создавать миграцию в БД, можно было заносить более мЕньшие и простые изменения в Liquibase. Попробовав локально      |
| этот инструмент и сравнив с миграциями в Laravel, обнаружил, что для проекта, где изменения происходят часто, Liquibase хорошо подходил -- легко отслеживались изменения и |
| сами изменения были хорошо структурированы. К сожалению, хоть это и привнесло бы удобство, это было отвергнуто, с тем, что нужно будет учить дополнительный инструмент для |
| небольшого проекта                                                                                                                                                         |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


+---------+
|#Пример 4|
+---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|    Внедрение ФП языков в разработку систем. За последний год, я стал прибегать к ФП все чаще, у которого достоинств немало -- иммутабельные структуры данных,              | 
| чистые функции, функции высшего порядка. Все это позволяет писать код, который может быть в несколько раз меньше, нежели код написанный на ООП, да и тестировать проще.    |
| Но, как мне видется по количеству вакансий и как я слышу по отзывам знакомых, ФП используется не так часто, в веду того, что писать на нем якобы дольше и сложнее.         |
| На самом деле, необязательно применять именно язык ФП; достаточно следовать его сути. В #примере 1 я переписал проект полностью. Но есть пример, когда я использовал       |
| ФП в перемешку с ООП.                                                                                                                                                      |
|    В один момент, в своем пет-преокте решил использовать данные из двух разлчиных инстансов БД (то есть было два различных коннекта с БД). Изначательно, когда БД была     |
| одна, была структура Handler, содержащая поле Storage -- интерфейс для работы с БД. Вызов функции для работы с БД, например вставка, выглядел следующим образом:           |
| err := h.Storage.Insert(entity). То есть, у меня могу быть единственный коннет для конкретного БД. Можно было бы добавить дополнительный коннект в структуру БД, но мне    |
| показался следующий подход более удачным. Я переписал модуль для взаимодействия с БД в функциональном стиле. Теперь, функции для работы с БД выглядели следующим образом:  |
| func Insert(e Entity, s Storage) error. Мне стало намного удобнее взять соответствующий инстанс из модуля БД и добавить в функцию. Но у данного подхода есть и минус.      |
| Я мало что могу сказать конкретного об Entity и Storage :)                                                                                                                 |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+---------+
|#Пример 5|
+---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|    Определенно, буду рассматривать выбор между "выбрать одну из возможных структуры данных" и "использововать несколько структур данных", то есть использовать избыточность| 
| информации. Например, использовать мапу не только, как k->v, но и как v->list(k). Внесение в код подобных "избыточных" структур данных, с одной стороны, может решить      |
| вопрос, связанный с моделью данных в проекте и их манипулированием. С другой, удобство синхронизации базовых структур данных уменьшается, что чревато усложнением системы. |
|     Попробовав пару раз подобный прием, проблем с синхронизацией не возникало и не приводило к серьезным усложнениям. К тому же, по мере "синхронизации", в АТД            |
| выводится сам инвариант, так что вопрос с усложнением системы не общий, а скорее частные случаи...                                                                         |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

+---------+
|По итогу |
+---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|    Я всегда представлял разработку, как постоянный нахождение постоянного компромисса. Выбор между простотой и масштабируемостью кода, выбор между простым и менее         |
| функциональным и сложный, но более серьезным инструментами -- это может варьироваться от стиля кодирования, до выбора СУБД. Я сталкивался с решением выбрать между двумя   |
| альтернативами. Коллега на работе мне подсказал хорошую мысль, которую запомнил и применяю, когда вопрос заходит о компромиссе: : "Важно не просто выбрать инструмент, но  |
| так грамотно ответить на вопросы зачем он нужен", то есть уметь пояснить за все его достоинства и недостатки и уже от этих свойств отталкиваться в процеесе выбора:.       |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
