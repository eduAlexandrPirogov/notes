# 3 свойства хорошего кода.

Здесь будут рассуждения лишь об одном проекте, т.к. мне потребовалось достаточно времени на формирования мыслей, которые хотел донести.

Сначала отвечу по поводу второго пунтка "понятности" кода, который применяю в профессиональной разработке вне зависимости от проектов:
1) Всегда пишу комментарии для namespac'а, которые говорят, что он включает в себя и в чем его цель.
2) Всегда пишу комментарии в виде пред и постусловий для функций. Это поможет определить домент корректной работы кода.

А вот поводу, насколько код должен быть замысловат, я отталкиваюсь от команды, в которой работаю и от проекта.
Например, на своей первой работе, где я только добавлял дополнительную функциональность и не руководил разработкой проекта, и в то же время
никто не был знаком с функциональным программированием, я бы не писал функции и методы в ко-рекурсивном стиле, программирование высшего порядка, fold/map/reduce. 
Конечно, все вышеперечисленное будет лучше, нежели if-ы в for, но порой убедить коллегу будет себе дороже, так что лучше писать так, как им будет понятно.
Но если бы разработкой некоторого проекта руководил я сам, то, например а README.md, написал бы переченей желательных применений стилей кода:

```
1) Старайтесь использовать fold/map/reducе вместо сырых циклов
2) Уменьшайте количество if-ов: измените логику или используйте map'ы
...
```

Если говорить на языке литературоведов, то руководимый мною проект будет владеть единым стилем, и всякому разработчику, знакомому с этим стилем, будет проще понять код.


А вот касательно первого и третьего пункта распишу одновременно, так как мне кажется третье есть прямо следствие первого.

## Проект "Автопарк"

Поскольку я нахожусь в поиске работы Go, где частенько упоминается требования понимание микросервисной архитектуры, дипломный проект стал переделывать с микросервисами,
параллельно изучая "Создание микросервисов" от Ньюмэна. 
Один из компонентов микросервисов отвечает за обработку заказов бронирования автомобилей. 
Заказ может быть в одном и некоторых состояний: создан, машина выбрана, подтвержден, завершен, отменен. Созданный заказ может "висеть" N минут, после чего, если он не был
подтвержден, он удаляется. Эта логика одна из самых сложных в проекте, но оттого и интереснее.
В чем заключается "законченность" кода для данного компонента? Корректная работы с сущностью "заказ" при определенном домене.
Чтобы говорить о том, что код - "закончен", нужно это доказать. Для доказательства имеем следующие мета-аксиомы:
1) заказ может переходить из одного состояние в другое, а имеет ограничение в переходе состояний (например, заказ не может быть отменен, если он был подтвержден или завершен).
2) если заказ находится в состоянии "новый" или "выбрана машина" и в течении N минут его состояние не изменилось, то он удаляется
3) нельзя создать пользователю заказ дважды

Касательно первого пункта, кто знаком с теорией конечных автоматов, все прозаически просто. Мы задаем состояние и допустимые переходу, а доказательство корректности не составит труда.
Касательно третьего пункта, можно использовать хэш-таблицу. Для любой сущности "заказ", если хэш-функция чистая функция, то вне зависимости от времени мы всегда получим одно и то же значение
хэша для одного и того же "заказа". (вопросы коллизии и прочией нюансы реализации структур данных я намеренно опущу, т.к. это другая область дискуссий). По факту, мы реализовали множества
для заказов, и если пользователь захочет создать существующий заказ, мы легко предотвратим это.
Второй пункт становится тривиальным после первых двух доказательств, поскольку он исполняется тогда и только тогда, когда истинны первый и второй пункт.

На самом деле тут получилось очень красиво не только с точки зрения "законченности" кода, но и то, как точно-подобранная абстракция упрощает разработку:
1) Заказы отражаются в конечные автоматы
2) Набор действиующих заказов отражается в контейнеры (в данном случае в хэш-таблицу)

Доказав "законченность" кода, перехожу к третьему пункту -- адаптивность кода к изменениям (ну или же эволюция).
Первое. Тут мне видится рекуррентное соотношение: код готов к измененияя в момент времени t тогда и только тогда, когда код закончен в момент времени t-1. То есть, если мы хотим иметь код, который
адаптивен, то он должен быть законченным. 

Второе. Если код был изменен в момент времени t, и утверждения в момент времени t-1 остаются в силе, то код в момент времени t можно считать законченным и готовым к следующим изменениям. 
Вот тут я поясню свою точку зрения на этом же примере. Перечислю ещё раз вышеприведенные абстракции, которые существуют в коде на время t1:
1) Заказы отражаются в конечные автоматы
2) Набор действиующих заказов отражается в контейнеры (в данном случае в хэш-таблицу)

Допустим на время t2 требуется добавить новое состояние для заказа. Мы изменяем код, переходим в t2, и с помощью теории автоматов легко доказываем корректность свойств, т.е все утверждения для t2 
действую для t1. Но это слишком просто :)
Допустим, один пользователь может создать несколько заказов (например, заранее забронировать несколько автомобилей, но не подтвердить заказ). Вы заметите, что хэш-таблица уже не подходит, 
и моя логика касательно адаптивности кода ломается, но тут я подвожу вас к важному дополнению:
Если код был изменен в момент времени t, и утверждения в момент времени t-1 остаются в силе, (!) и при этом свойства для некоторого нашего компонента, полученные из бизнес-требования, не были изменениы,
то код в момент времени t можно считать законченным и готовым к следующим изменениям. Если же свойства относительно компонента (как в нашем случае ограничение количества создания заказов относительно контейнеров)
был изменены, то мы добавляем новую точку m на оси координат времени T, до которой утверждение об адаптивности работает, и с момента времени m мы формулируем новые доказательства и свойства. 
Надеюсь рисунок ниже поможет понять:

Дана абсцисса времени
t0---------t1------t2-------m1-------t3-----t4----t5------> T

1) мой компонент бронирования заказов находится в точке t0
2) требуется добавить новое состояние заказа. Мы добавляем это состояние и переводим проект в t1. Все утверждения для t1 корректны также для t0.
3) вместо хэш таблиц вдруг потребовалось использовать иную структуру данных (например для эффективности). Мы также вносим изменения и переводим проект из t1 в t2. Опять же, свойства относительно состояний заказов и относительно 
ограничений состояний заказов будут верны, что для t2, что для t1, что для t0
4) допустим нам приходит изменения, что пользователь может создавать несколько заказов. Таким образом наше свойство относительно контейнеров "ломается". Мы вносим изменения, переводим систему в состояние m1
5) Теперь мы добавили три новые функциональности перевели наш проект из состояния m1 в t5.

И суть такова: все утверждения относительно свойств компонентов (в нашем случае, как с точки зрения разработчиков, свойств абстракций) в момент времени t5 будут верны для t4,t3,m1, но неверны для t2,t1,t0. 
m1 можно зафиксировать как мажорную версию проекта.

И вот вывод касательно адаптируемости кода у меня таков: чтобы код был адаптируем, мы должны сформулировать некоторые свойства. Сформулировав, мы ищем абстракции, которые настолько точно, насколько это возможно отражают эти свойства.
Отражаем эти абстркции в код, а в качестве подтверждения свойств используем TDD. Если требуется внести изменения, которые ещё не дошли до точки m1 (наши свойства не ломаются), то мы думает смотрим на реализацию наших абстракций, 
изменяем их, проверяя ранее написаными тестами. Если требуется изменить саму абстракцию, то мы ищем из семейства абстракций такую, которую можно полиморфно подставить вместо старой. 
Если же бизнес-требования сильно изменились, ломая наши свойства, то лучше переработать систему целиком или параллельно разрабатывать новую версию.

Теории получилось много, но вот относительно адаптивности кода отношение, мнение у меня такое -- мы думаем на более высоком уровне, формулируя свойства и доказательства, выбирая абстракции и далее по ним работаем. 
Если требования координально изменились, то и разработку надо всю пересматривать (параллельно или заного).


По итогу:
Я бы сказал, что эти три свойства можно применять не только к проектам, а к участкам кода, согласно рекурсивному определению:
Программа = набор подпрограмм
т.е. если наша подпрограмма соответствует трем вышеприведенным свойствам, то и программа будет соответствовать трем вышеприведенным свойства. Это мнение основано на индукции, за его корректность не ручаюсь.
Если с пунктом по понятности кода у меня уже сформировались принципы, касательно пунтка о "законченности" кода у меня есть понимание, как определять "закончен ли код или нет", то вот с пунктом "адаптивности" 
все сложнее, но это давняя проблема разработки ПО. С этим можно бороться, делая код наиболее автономным, гибким, модульным. Мне кажется, что сейчас мы ограничены сверху существующими инструментами, которые сделали
программирование довольно легким, но разработку -- сложным.
Добавил для себя в gist, где храню чек-лист по разработке следующие вопросы:
1) мой код закончен ?
2) будет ли мой код понятен?
