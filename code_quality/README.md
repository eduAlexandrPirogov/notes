# 3 свойства хорошего кода.

Сначала отвечу по поводу второго пунтка "понятности" кода, который применяю в профессиональной разработке вне зависимости от проектов:
1) Всегда пишу комментарии для namespac'а, которые говорят, что он включает в себя и в чем его цель.
2) Всегда пишу комментарии в виде пред и постусловий для функций. Это поможет определить домент корректной работы кода.

А вот поводу, насколько код должен быть замысловат, я отталкиваюсь от команды, в которой работаю и от проекта.
Например, на своей первой работе, где я только добавлял дополнительную функциональность и не руководил разработкой проекта, и в то же время
никто не был знаком с функциональным программированием, я бы не писал функции и методы в ко-рекурсивном стиле, программирование высшего порядка, fold/map/reduce. 
Конечно, все вышеперечисленное будет лучше, нежели if-ы в for, но порой убедить коллегу будет себе дороже, так что лучше писать так, как им будет понятно.
Но если бы разработкой некоторого проекта руководил я сам, то, например а README.md, написал бы переченей желательных применений стилей кода:

```
1) Старайтесь использовать fold/map/reducе вместо сырых циклов
2) Уменьшайте количество if-ов: измените логику или используйте map'ы
...
```

Если говорить на языке литературоведов, то руководимый мною проект будет владеть единым стилем, и всякому разработчику, знакомому с этим стилем, будет проще понять код.


А вот касательно первого и третьего пункта распишу одновременно, так как мне кажется третье есть прямо следствие первого.

## Проект "Автопарк"

Поскольку я нахожусь в поиске работы Go, где частенько упоминается требования понимание микросервисной архитектуры, дипломный проект стал переделывать с микросервисами,
параллельно изучая "Создание микросервисов" от Ньюмэна. 
Один из компонентов микросервисов отвечает за обработку заказов бронирования автомобилей. 
Заказ может быть в одном и некоторых состояний: создан, машина выбрана, подтвержден, завершен, отменен. Созданный заказ может "висеть" N минут, после чего, если он не был
подтвержден, он удаляется. Эта логика одна из самых сложных в проекте, но оттого и интереснее.
В чем заключается "законченность" кода для данного компонента? Корректная работы с сущностью "заказ" при определенном домене.
Чтобы говорить о том, что код - "закончен", нужно это доказать. Для доказательства имеем следующие мета-аксиомы:
1) заказ может переходить из одного состояние в другое, а имеет ограничение в переходе состояний (например, заказ не может быть отменен, если он был подтвержден или завершен).
2) если заказ находится в состоянии "новый" или "выбрана машина" и в течении N минут его состояние не изменилось, то он удаляется
3) нельзя создать пользователю заказ дважды

Касательно первого пункта, кто знаком с теорией конечных автоматов, все прозаически просто. Мы задаем состояние и допустимые переходу, а доказательство корректности не составит труда.
Касательно третьего пункта, можно использовать хэш-таблицу. Для любой сущности "заказ", если хэш-функция чистая функция, то вне зависимости от времени мы всегда получим одно и то же значение
хэша для одного и того же "заказа". (вопросы коллизии и прочией нюансы реализации структур данных я намеренно опущу, т.к. это другая область дискуссий). По факту, мы реализовали множества
для заказов, и если пользователь захочет создать существующий заказ, мы легко предотвратим это.
Второй пункт становится тривиальным после первых двух доказательств, поскольку он исполняется тогда и только тогда, когда истинны первый и второй пункт.

На самом деле тут получилось очень красиво не только с точки зрения "законченности" кода, но и то, как точно-подобранная абстракция упрощает разработку:
1) Заказы отражаются в конечные автоматы
2) Набор действиующих заказов отражается в контейнеры (в данном случае в хэш-таблицу)

Доказав "законченность" кода, перехожу к третьему пункту -- адаптивность кода к изменениям (ну или же эволюция).
Первое. Тут мне видится рекуррентное соотношение: код готов к измененияя в момент времени t тогда и только тогда, когда код закончен в момент времени t-1. То есть, если мы хотим иметь код, который
адаптивен, то он должен быть законченным. 

Второе. Если код был изменен в момент времени t, и утверждения в момент времени t-1 остаются в силе, то код в момент времени t можно считать законченным и готовым к следующим изменениям. 
Вот тут я поясню свою точку зрения на этом же примере. Перечислю ещё раз вышеприведенные абстракции, которые существуют в коде на время t1:
1) Заказы отражаются в конечные автоматы
2) Набор действиующих заказов отражается в контейнеры (в данном случае в хэш-таблицу)

Допустим на время t2 требуется добавить новое состояние для заказа. Мы изменяем код, переходим в t2, и с помощью теории автоматов легко доказываем корректность свойств, т.е все утверждения для t2 
действую для t1. Но это слишком просто :)
Допустим, один пользователь может создать несколько заказов (например, заранее забронировать несколько автомобилей, но не подтвердить заказ). Вы заметите, что хэш-таблица уже не подходит, 
и моя логика касательно адаптивности кода ломается, но тут я подвожу вас к важному дополнению:
Если код был изменен в момент времени t, и утверждения в момент времени t-1 остаются в силе, (!) и при этом свойства для некоторого нашего компонента, полученные из бизнес-требования, не были изменениы,
то код в момент времени t можно считать законченным и готовым к следующим изменениям. Если же свойства относительно компонента (как в нашем случае ограничение количества создания заказов относительно контейнеров)
был изменены, то мы добавляем новую точку m на оси координат времени T, до которой утверждение об адаптивности работает, и с момента времени m мы формулируем новые доказательства и свойства. 
Надеюсь рисунок ниже поможет понять:

Дана абсцисса времени
t0---------t1------t2-------m1-------t3-----t4----t5------> T

1) мой компонент бронирования заказов находится в точке t0
2) требуется добавить новое состояние заказа. Мы добавляем это состояние и переводим проект в t1. Все утверждения для t1 корректны также для t0.
3) вместо хэш таблиц вдруг потребовалось использовать иную структуру данных (например для эффективности). Мы также вносим изменения и переводим проект из t1 в t2. Опять же, свойства относительно состояний заказов и относительно 
ограничений состояний заказов будут верны, что для t2, что для t1, что для t0
4) допустим нам приходит изменения, что пользователь может создавать несколько заказов. Таким образом наше свойство относительно контейнеров "ломается". Мы вносим изменения, переводим систему в состояние m1
5) Теперь мы добавили три новые функциональности перевели наш проект из состояния m1 в t5.

И суть такова: все утверждения относительно свойств компонентов (в нашем случае, как с точки зрения разработчиков, свойств абстракций) в момент времени t5 будут верны для t4,t3,m1, но неверны для t2,t1,t0. 
m1 можно зафиксировать как мажорную версию проекта.


 
