# 3 свойства хорошего кода.

Сначала отвечу по поводу второго пунтка "понятности" кода, который применяю в профессиональной разработке вне зависимости от проектов:
1) Всегда пишу комментарии для namespac'а, которые говорят, что он включает в себя и в чем его цель.
2) Всегда пишу комментарии в виде пред и постусловий для функций. Это поможет определить домент корректной работы кода.

А вот поводу, насколько код должен быть замысловат, я отталкиваюсь от команды, в которой работаю и от проекта.
Например, на своей первой работе, где я только добавлял дополнительную функциональность и не руководил разработкой проекта, и в то же время
никто не был знаком с функциональным программированием, я бы не писал функции и методы в ко-рекурсивном стиле, программирование высшего порядка, fold/map/reduce. 
Конечно, все вышеперечисленное будет лучше, нежели if-ы в for, но порой убедить коллегу будет себе дороже, так что лучше писать так, как им будет понятно.
Но если бы разработкой некоторого проекта руководил я сам, то, например а README.md, написал бы переченей желательных применений стилей кода:

```
1) Старайтесь использовать fold/map/reducе вместо сырых циклов
2) Уменьшайте количество if-ов: измените логику или используйте map'ы
...
```

Если говорить на языке литературоведов, то руководимый мною проект будет владеть единым стилем, и всякому разработчику, знакомому с этим стилем, будет проще понять код.


А вот касательно первого и третьего пункта распишу одновременно, так как мне кажется третье есть прямо следствие первого.

## Проект "Автопарк"

Поскольку я нахожусь в поиске работы Go, где частенько упоминается требования понимание микросервисной архитектуры, дипломный проект стал переделывать с микросервисами,
параллельно изучая "Создание микросервисов" от Ньюмэна. 
Один из компонентов микросервисов отвечает за обработку заказов бронирования автомобилей. 
Заказ может быть в одном и некоторых состояний: создан, машина выбрана, подтвержден, завершен, отменен. Созданный заказ может "висеть" N минут, после чего, если он не был
подтвержден, он удаляется. Эта логика одна из самых сложных в проекте, но оттого и интереснее.
В чем заключается "законченность" кода для данного компонента? Корректная работы с сущностью "заказ" при определенном домене.
Чтобы говорить о том, что код - "закончен", нужно это доказать. Для доказательства имеем следующие мета-аксиомы:
1) заказ может переходить из одного состояние в другое, а имеет ограничение в переходе состояний (например, заказ не может быть отменен, если он был подтвержден или завершен).
2) если заказ находится в состоянии "новый" или "выбрана машина" и в течении N минут его состояние не изменилось, то он удаляется
3) нельзя создать пользователю заказ дважды

Касательно первого пункта, кто знаком с теорией конечных автоматов, все прозаически просто. Мы задаем состояние и допустимые переходу, а доказательство корректности не составит труда.
Касательно третьего пункта, можно использовать хэш-таблицу. Для любой сущности "заказ", если хэш-функция чистая функция, то вне зависимости от времени мы всегда получим одно и то же значение
хэша для одного и того же "заказа". (вопросы коллизии и прочией нюансы реализации структур данных я намеренно опущу, т.к. это другая область дискуссий). По факту, мы реализовали множества
для заказов, и если пользователь захочет создать существующий заказ, мы легко предотвратим это.
Второй пункт становится тривиальным после первых двух доказательств, поскольку он исполняется тогда и только тогда, когда истинны первый и второй пункт.

На самом деле тут получилось очень красиво не только с точки зрения "законченности" кода, но и то, как точно-подобранная абстракция упрощает разработку:
1) Заказы отражаются в конечные автоматы
2) Набор действиующих заказов отражается в контейнеры (в данном случае в хэш-таблицу)

Доказав "законченность" кода, перехожу к третьему пункту -- адаптивность кода к изменениям (ну или же эволюция).
Первое. Тут мне видится рекуррентное соотношение: код готов к измененияя в момент времени t тогда и только тогда, когда код закончен в момент времени t-1. То есть, если мы хотим иметь код, который
адаптивен, то он должен быть законченным. 

Второе. Если код был изменен в момент времени t, и утверждения в момент времени t-1 остаются в силе, то код в момент времени t можно считать законченным и готовым к следующим изменениям. 
Вот тут я поясню свою точку зрения на этом же примере. Перечислю ещё раз вышеприведенные абстракции, которые существуют в коде на время t1:
1) Заказы отражаются в конечные автоматы
2) Набор действиующих заказов отражается в контейнеры (в данном случае в хэш-таблицу)

Допустим на время t2 требуется добавить новое состояние для заказа. Мы изменяем код, переходим в t2, и с помощью теории автоматов легко доказываем корректность свойств, т.е все утверждения для t2 
действую для t1. Но это слишком просто :)
Допустим, пользователь может 
