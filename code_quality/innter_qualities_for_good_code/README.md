# 4 внутренних свойства хорошего кода

Проект 1. Чтение и аггрегация метрик ОС.

1. Хороший код можно (и нужно) понимать модульно.
Что я понимаю под этим: насколько легко, глядя на единицу проекта, можно сказать о нем утверждений а) относительно его самого (внутреннее строение) б) относительно его влияния на систему
(как он вписывается в нее целиком).



2. Хороший код позволяет быстро восстановить замысел программиста.
Как можно измерить данную характеристику? Я бы предложил ответить на следующий вопрос "сколько мнений у вас сложилось при изучении единицы проектв?"
То есть, как многим дизайнам соответствует данный код?

Чем меньше вариантов дизайнов, тем лучше. Рассмотрим пример:

```go
// Trackers are used to collect all types of measures
//
// Trackers request measures to update own inner metrics
package trackers

// New Creates new instance of MetricTrackers
//
// Post-cond: Creates new instance of MetricsTracker
func New() MetricsTracker {
	...
}

type Trackerable interface {
  // InvokeTrackers Pre-cond:
  //
  // Post-cond: requests measures to update own metrics.
  // returns 0 if success otherwise we can return error_code
	InvokeTrackers()
}

// MetricsTracker Holds all measures in slice
type MetricsTracker struct {
	Metrics []metrics.Metricable
}

func (g *MetricsTracker) InvokeTrackers() error {
	for _, tracker := range g.Metrics {
		err := tracker.Read()
		if err != nil {
			return err
		}
	}
	return nil
}
``` 
Я бы выделил неудачное название интерфейса Trackerable, который имеет метод InvokeTrackers().Т.е Trackarable говорит о том, что тип, удовлетворяющий данному интерфейсу явно должен быть
чем-то единственным и не автономным (в плане, базовый кирпичик чего-то более комплексного), когда как InvokeTrackers() говорит о том, что он должен содержать множественные Trackers. 
Тут уже возникает неоднозначность и противоречние. Исправить можно следующим образом:

```
type TrackersInvoker interface {
  // Run invokes trackers to do job
  //
  // Post-cond: requests measures to update own metrics.
  // returns 0 if success otherwise we can return error_code
	Run()
}
```

Мы изменили с Trackerable до TrackersInvoker, тем самым дав понять, что интерфейс подразумвает работу с Trackers (множественное число), а также изменили метод с Invoke() на Run(), тем
самым дав понять, что мы запускаем некоторую работу над этими Trackers.

Насколько мой проект соответствует замыслу? Это одно из моих слабых мест по выбору хорошего имени для единицы программы, и такая ситуация возникает в каждом 4-ом компоненте в среднем.
Т.е. в каждом 4-ом компоненте у меня вонзикает желание переименовать на более подходящее по смысле.
Я бы сказал, что 25-30% единиц проекта могут легко дать понять замысел иному программисту.

3. Хороший код выражает замысел разработчика в одном месте.
Что я понимаю под этим: насколько точно я выразил абстракцию в коде и насколько она автономна. Сразу допустим, что абстракция подобрана хорошо.
На Яндекс-Практикуме для сериализации метрик нам дали следующую структуру от которой мне становится не по душе:
```go
// Serializable representation of metric
type Metrics struct {
	ID    string   `json:"id"`              //Metric name
	MType string   `json:"type"`            // Metric type: gauge or counter
	Delta *int64   `json:"delta,omitempty"` //Metric's val if passing counter
	Value *float64 `json:"value,omitempty"` //Metric's val if passing gauge
	Hash  string   `json:"hash,omitempty"`
}
```

С одной стороны, если придет некоторое изменение касательно структуры, то нам можно заявить, мол, "все изменения касательно сериализации метрик будут касательно только этой структуры".
Но я не согласен. Тут надо смотреть на первый пункт "понимать код модульно". Все изменения, которые коснуться данной структуре повлекут за собой изменение вне этого кода.
Поскольку через if-else мы проверяем mtype, то, изменив mtype, мы подвергаем изменениям все if-else, следовательно все, что касатется MType размазано по проекту.

Приведу аналогию, которая поможет лучше понять мою мысль. Допустим, мы делаем входные двери, которые работают по отпечатку пальца. 
В случае, если нам потребуется внести небольшое изменение в алгоритм распознавания пальца, нам не нужно ходить по квартирам, чтобы лезть в "биос" двери и "подгонять фичу".
И вот в случае метрик получается, что изменив MTypе, нам нужно изменить код не в едином месте.

Как я решил данную проблему. Во-первых, я задал себе условие, что это легаси-код, который нельзя изменять. Во-вторых, разделил логику для разных типов метрик.
В-третьих, создал модуль, который читает эту кашу Metrics, и выдает "кирпичик".

Получилось следующее: создал интерфейс Tupler, который отражает работус кортежами. Создал факторку, которая в зависимости от MType создает структуру Tuple, удовлетворяющая Tupler.
То есть, GaugeTuple, CounterTupler. Получились следующие плюсы:
1) Все изменение, касающееся изменений Metrics, будет касаться этих Metrics и факторки.
2) Поскольку я создал "кирпичик" алгебру Tuple, то моя остальная система не зависит от Metrics и факторки - она работает с кортежами! Алгебра моей системы будет корректна до тех пор, пока
подаются корректные кортежи!

Мне очень нравится подобным образом рефакторить проекты, посему мои текущие проекты соответствуют данному требованию более чем на 70%.

4. Хороший код надёжен/робастен (несильные изменения требований подразумевают несильное изменение кода).


Проект 2.
