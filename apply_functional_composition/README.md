# Применяем функциональную композицию правильно

# Пример 1

Рабочий внутркорпоративный проект первой работы, который заключался все также в экстраполяции финансовых данных для сервисов-партнеров.
Для каждого сервиса нужно была рассчитать общий оборот по алгоритму А1 и оборот-прогноз на следующие месяцы, по алгоритму А2. Алгоритм А2 базировался в большинстве своем на алгоритме А1,
то есть на основе вычисленного общего оборота, нужноб ыло добавить коэффициенты.

Изначально это было сделано так: был класс TurnoverFinancialManager, который реализовывал А1, и от него наследовался TurnoverForecastFinancialManager, который реализовывал А2.
Со временем требования к рассчету алгоритма А2 менялись для некоторых сервисов, из-за чего приходилась в код добавлять if-ы. Да и в целом я тогда с ФП знаком не был :)

В общем и целом, сейчас бы я сделал это следующим образом: 
1) Создал бы функция для рассчета общего оборота
```go
func Turnover(s services.Service) int64 {
   ...
   return turnover
}
```

2) Для каждого алгоритма А2, который основывается на A1, написал бы функцию рассчета прогноза:

```go
// Стандартый рассчет
func ForecastDefault(int64 turnover, s services.Service) int64 {
     ...
     return forecast
}

// Экстраполяция в зависимости от периода даты
func ForecastByMonths(m daterange.MonthesAgo, s services.Service) forecast {
     ...
     return forecast
}
```

3) По мере написания для каждого случая экстраполяции, выделил бы автономную функцию, которую можно выявить среди всех функций. Например, одно из частовстречающихся цепочек вычислений:

```go
// Высчитываем разницу между увеличенной суммой и показателем difference
// Чем большая разница между given + increaseBy и difference, тем меньше был рассчет,
// что сервис принесет деньги в след месяце
func IncreaseByAndDifference(given int64, increaseBy int64, difference int64) int64 {
      return (given + increaseBy) - difference
}
```

4) Вынес бы подобные автономные функции в отдельную либу/пакет/модуль. Теперь, для рассчета сервисов, использовался следующий механизм:
Имели бы чистую функцию, на которой базируется вычисление прогноза:
```go
// Чистая функция для рассчета оборота
func Turnover(s service.Service) int64 {
    ...
    return turnover
}
```

Имелись набор автономных функцих, для вычислений прогноза (см. пункт 3).
Поскольку для каждого сервиса поток вычислений был известен, то создал бы мапу, где для в качестве ключа выступал сервис, а в качестве значения -- список функций, применяемых для экстраполяции,
и использовал свертку-fold, который применял бы функции к соответствующим исходным данным.

Что это дало -- будет подробно описано в выводе.

# Пример 2
