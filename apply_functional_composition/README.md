# Применяем функциональную композицию правильно

# Пример 1

Рабочий внутркорпоративный проект первой работы, который заключался все также в экстраполяции финансовых данных для сервисов-партнеров.
Для каждого сервиса нужно была рассчитать общий оборот по алгоритму А1 и оборот-прогноз на следующие месяцы, по алгоритму А2. Алгоритм А2 базировался в большинстве своем на алгоритме А1,
то есть на основе вычисленного общего оборота, нужноб ыло добавить коэффициенты.

Изначально это было сделано так: был класс TurnoverFinancialManager, который реализовывал А1, и от него наследовался TurnoverForecastFinancialManager, который реализовывал А2.
Со временем требования к рассчету алгоритма А2 менялись для некоторых сервисов, из-за чего приходилась в код добавлять if-ы. Да и в целом я тогда с ФП знаком не был :)

В общем и целом, сейчас бы я сделал это следующим образом: 
1) Создал бы функция для рассчета общего оборота
```go
func Turnover(s services.Service) int64 {
   ...
   return turnover
}
```

2) Для каждого алгоритма А2, который основывается на A1, написал бы функцию рассчета прогноза:

```go
// Стандартый рассчет
func ForecastDefault(int64 turnover, s services.Service) int64 {
     ...
     return forecast
}

// Экстраполяция в зависимости от периода даты
func ForecastByMonths(m daterange.MonthesAgo, s services.Service) forecast {
     ...
     return forecast
}
```

3) По мере написания для каждого случая экстраполяции, выделил бы автономную функцию, которую можно выявить среди всех функций. Например, одно из частовстречающихся цепочек вычислений:

```go
// Высчитываем разницу между увеличенной суммой и показателем difference
// Чем большая разница между given + increaseBy и difference, тем меньше был рассчет,
// что сервис принесет деньги в след месяце
func IncreaseByAndDifference(given int64, increaseBy int64, difference int64) int64 {
      return (given + increaseBy) - difference
}
```

4) Вынес бы подобные автономные функции в отдельную либу/пакет/модуль. Теперь, для рассчета сервисов, использовался следующий механизм:
Имели бы чистую функцию, на которой базируется вычисление прогноза:
```go
// Чистая функция для рассчета оборота
func Turnover(s service.Service) int64 {
    ...
    return turnover
}
```

Имелись набор автономных функцих, для вычислений прогноза (см. пункт 3).
Поскольку для каждого сервиса поток вычислений был известен, то создал бы мапу, где для в качестве ключа выступал сервис, а в качестве значения -- список функций, применяемых для экстраполяции,
и использовал свертку-fold, который применял бы функции к соответствующим исходным данным.

Что это дало -- будет подробно описано в выводе.

# Пример 2

Иная неочеввидная область применения данного приема -- построения GUI, как например с помощью wxWidgets. Общий алгоритм построения GUI довольно прост -- создаем элемент, присваиваем ему панель 
Panel, и на эту панель накидываем следующий элемент со своей панелью и так далее. Для подобной "компоновки" элементов у wxWidgets имелись два общих метода:

1) wxPanel->Add(wxWidget, params...)
2) SetSizeAndFit(wxPanel)

В дипломном проекте, где я создавал GUI на плюсах, очень любил использовать наследование, которое достигало 3-4 уровней и присутствовал tight coupling. Получалась такая иерархия:

wxPanel <-- wxSplittedHorizontalPanel <-- wxScrolledPanel <-- ... 


Тут можно поступить очень интересно 
следующим образом: 

1) Для каждого используемого элемента создать функцию. Наприимер:

```cpp
wxButton* createButton(wxButton ... params) {
   wxButton *btn = new wxButton()    
   // Assigning params to btn
   return btn
}

wxComboBox* createCombobox(wxComboBox ... params) {
     // Assignng params to creating instance wxComboBox
    return combobox
}
```
C панелями функции были бы абсолютно такими же

2) Для создания какого-либо элемента, использовал бы набор автономных вышеприведенных функций:

```cpp
wxPanel aggrQueryPanel = new wxPanel()
aggreQueryPanel->Add(
   (createSplittedPanel(params)->Append(
      (createwxButton(params), 
      createStatixText(params)
    )
)
```

Суть такова, что мы выполняем подобную композицию за счет функций, тем самым я избавляюсь от наследования + жирных конструкторов в классе, как например:

```cpp
AggrQueryPanel::wxScrolledPanel(wxWindow* parent, ReportMainPanel* mainReportParent) 
	: wxScroll(parent, wxID_ANY)
{
	mainReportPanel = mainReportParent;
	collection = new wxComboBox(this, 27000, wxEmptyString, wxPoint(15, 15));
	exec = new wxButton(this, 27010, "Âûïîëíèòü çàïðîñ", wxPoint(15,50));
	reset = new wxButton(this, 27011, "Íîâûé çàïðîñ", wxPoint(15, 75));
	add_group_function = new wxButton(this, 27013, "Äîáàâèòü ôóíêöèþ", wxPoint(15, 100));
	add_group_field = new wxButton(this, 27012, "Äîáàâèòü àãð. ïîëå", wxPoint(15, 125));
	add_group_by_field = new wxButton(this, 27014, "Ãðóïïèðîâêà ïî", wxPoint(15, 150));
	add_group_function->Disable();
	add_group_field->Disable();

	wxStaticText *st_func_type = new wxStaticText(this, wxID_ANY, "Ôóíêöèÿ", wxPoint(250, 5));
	wxStaticText *st_aggr_field = new wxStaticText(this, wxID_ANY, "Àãðåãèðóåìîå ïîëå", wxPoint(400, 5));
	wxStaticText *st_group_by = new wxStaticText(this, wxID_ANY, "Ðàçäåëÿåì ïî", wxPoint(550, 5));
	wxStaticText *st_field_name = new wxStaticText(this, wxID_ANY, "Íàçâàíèå ïîëÿ", wxPoint(700, 5));
}
```

# Более примеров подходящих не нашел, в основном ООП рабочие проекты были CRUD-ами без вычислений, либо приходилось уж слишком "притягивать за уши".

===================================================================================================================================================================================================

Резюме. 
То, что композиция лучше наследования, мне вдалбливали ещё на первых курсах универа, и вроде бы я должен был поверить на слово, но нет. Да, (ООП) композиция в каком-то смысле гибче наследования,
но если наследования мне представлялось как дерево, поддервья которого растут "вниз" по иерархии и зависимы от родителя, но и композиция мне виделась также деревом, поддереврья которого 
"растут вглубь", но в данном случае родитель зависим от поддеревьев (как мне кажется, если мы сломаем интерфейс поддерева, то родитель-дерево не сможет им пользоваться).
Например, если рассмотреть мною вышеприведенный пример, то: иерархия наследования была такова -- TurnoverFinancialManager от которого наследуется TurnoverForecastFinancialManager, то есть мы 
растем вниз по иерархии. Если бы мы использовали классическую композицию, то получили бы, что внутри TurnoverFinancialManager просто хранился бы экземпляр TurnoverForecastFinancialManager.
В первом случае, TurnoverForecastFinancialManager зависим от TurnoverFinancialManager, а во втором наборот (в случае изменения TurnoverFinancialManager мы бы изменяли способ обращения к нему из
TurnoverFinancialManager). 
Схематически то выглядит так в моей голове:
Наследование --  TurnoverForecastFinancialManager (первый уровень пространства наследования) <-- TurnoverFinancialManager (второй уровень пространства наследования) <--
Композиция -- TurnoverFinancialManager (первый уровень пространства композиции) <--  TurnoverForecastFinancialManager (второй уровень пространства композиции)  <--

То есть мысль моя такова, что хоть стандартная ООП композиция будет лучшим решением, нежели наследование, оно не решает проблему coupling'a. Но если мы применяем функциональную композицию, 
"вытапливая жир", то тут картина совершенно иная. Создав автономные функции, все они будут находиться на одном уровне пространстве. Из них легко создаются новые функции посредством compose, но
мякотка, как мне видется здесь, в том, что мы можем создавать сложные вычисления функций с помощью map/filter/reduce/fold и при этом оставаться все на одном уровне пространства сложности!

Тут лучше всего привести пример с вычислениями зарплатой и премий. Премия может высчитываться комплексными вычислениями, и, делая это в ООП, тут на ум приходит композиция, которая в свою очередь 
пораждают создание новых классов, их вложенности и так далее. С функциональным же подходом, все функции будут находиться в одном пространстве, максимум, куда мы выйдет -- это в функции высшего
порядка, которые к тому же независимы друг от друга.

Это невероятно крутой прием и осознание его мощности дает понять, что функциональщина -- ТОП :)
